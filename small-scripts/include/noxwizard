// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// || NoX-Wizard Scripts (noxwizard)                                      ||
// || Maintained by Xanathar, Ummon                                       ||
// || Great contributions of : Sparhawk, Luxor, Connor                    ||
// || Last Update (04-mar-03)                                             ||
// || -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- ||
// || This file contains NoX-Wizard standard native prototypes            ||
// || -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- ||
// || Designed for NXW version 0.82s                                      ||
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


#if defined _nxw_included
  #endinput
#endif
#define _nxw_included

/**
 * \defgroup script Script
 * All Script stuff
 */


/**
 * \defgroup script_API API
 * \ingroup script
 * All API
 */


/*************************************************************************
 *PRECOMPILATION PROPERTIES
 *************************************************************************/
const NXWINC_VERSION = 0x060;

/*************************************************************************
 *CORE NATIVE FUNCTIONS [(C) ITB Compuphase]
 *************************************************************************/

/** \defgroup script_API_native Core native functions
 *  \ingroup script_API
 *  @{
 */

native heapspace();
native funcidx(const name[]);
native numargs();
native getarg(arg, index=0);
native setarg(arg, index=0, value);
native strlen(const string[]);
native strpack(dest[], const source[]);
native strunpack(dest[], const source[]);
native tolower(c);
native toupper(c);
native swapchars(c);
native random(max);
native min(value1, value2);
native max(value1, value2);
native clamp(value, min=cellmin, max=cellmax);
native getproperty(id=0, const name[]="", value=cellmin, string[]="");
native setproperty(id=0, const name[]="", value=cellmin, const string[]="");
native deleteproperty(id=0, const name[]="", value=cellmin);
native existproperty(id=0, const name[]="", value=cellmin);
native printf(const format[], ...);

/** @} */ // end of script_API_native

/*************************************************************************
 *GENERAL PURPOSE FUNCTIONS
 *************************************************************************/

/** \defgroup script_API_general General Purpose functions
 *  \ingroup script_API
 *  @{
 */

/*!
\funcname callFunction
\brief calls a function without parameters
\author Luxor
\syntax callFunction( const functionIndex )
*/
native callFunction( const functionIndex );

/*!
\funcname callFunction1P
\brief calls a function with 1 parameter
\author Luxor
\syntax callFunction1P( const functionIndex, const param1 )
*/
native callFunction1P( const functionIndex, const param1 );

/*!
\funcname callFunction2P
\brief calls a function with 2 parameters
\author Luxor
\syntax callFunction2P( const functionIndex, const param1, const param2 )
*/
native callFunction2P( const functionIndex, const param1, const param2 );

/*!
\funcname callFunction3P
\brief calls a function with 3 parameters
\author Luxor
\syntax callFunction3P( const functionIndex, const param1, const param2, const param3 )
*/
native callFunction3P( const functionIndex, const param1, const param2, const param3 );

/*!
\funcname callFunction4P
\brief calls a function with 4 parameters
\author Luxor
\syntax callFunction4P( const functionIndex, const param1, const param2, const param3, const param4 )
*/
native callFunction4P( const functionIndex, const param1, const param2, const param3, const param4 );


/*!
\funcname callFunction5P
\brief calls a function with 5 parameters
\author Luxor
\syntax callFunction5P( const functionIndex, const param1, const param2, const param3, const param4, const param5 )
*/
native callFunction5P( const functionIndex, const param1, const param2, const param3, const param4, const param5 );

/** @} */ // end of script_API_general

/** \defgroup script_API_file File management functions
 *  \ingroup script_API
 *  @{
 */

/*!
\funcname file_open
\brief Opens a file for reading and or writing
\author Sparhawk
\since 0.82
\syntax file_open(const filename[], const openmode[] )
\param	filename	- name of the file to open
\param	openmode	- mode in which to open the file ( conform fopen() syntax )
\return	symbolic numerical file handle or INVALID
*/
native file_open(const filename[], const openmode[] );

/*!
\funcname file_close
\brief Closes a file
\author Sparhawk
\since 0.82
\syntax file_close( const handle )
\param	handle	- file handle obtained from file_open()
\return	true on success else false
*/
native file_close( const handle );

/*!
\funcname file_eof
\brief Check for end of file situation
\author Sparhawk
\since 0.82
\syntax file_eof( const handle )
\param	handle	- file handle obtained from file_open()
\return	true on end of file else false
*/
native file_eof( const handle );

/*!
\funcname file_write
\brief Write a string to a file
\author Sparhawk
\since 0.82
\syntax file_write(const handle, const text[] )
\param	handle	- file handle obtained through file_open()
\param	text	- string to write to file
\return	true on success else false
*/
native file_write(const handle, const text[] );

/*!
\funcname file_read
\brief Read a line from a file
\author Sparhawk
\since 0.82
\syntax file_read(const handle, line[] )
\param	handle	- file handle obtained through file_open()
\param	line	- Array in to which line read is stored
\return	true
*/
native file_read(const handle, line[] );

/** @} */ // end of script_API_file

/** \defgroup script_API_log Log management functions
 *  \ingroup script_API
 *  @{
 */

/*!
\funcname log_message
\brief Prints a message to the message log
\author Sparhawk
\since 0.82
\syntax log_message(const format[], ...)
\param format[]: the message
*/
native log_message(const format[], ...);

/*!
\funcname log_warning
\brief Prints a message to the warning log
\author Sparhawk
\since 0.82
\syntax log_warning(const format[], ...)
\param format[]: the message
*/
native log_warning(const format[], ...);

/*!
\funcname log_error
\brief Prints a message to the error log
\author Sparhawk
\since 0.82
\syntax log_error(const format[], ...)
\param format[]: the message
*/
native log_error(const format[], ...);

/*!
\funcname log_critical
\brief Prints a message to the critical error log
\author Sparhawk
\since 0.82
\syntax log_critical(const format[], ...)
\param format[]: the message
*/
native log_critical(const format[], ...);

/** @} */ // end of script_API_log

/** \defgroup script_API_nnsodove Funzioni da spostare
 *  \ingroup script_API
 *  @{
 */

/*!
\funcname nprintf
\brief Prints a message to the given socket
\author Xanathar
\syntax nprintf(const socket, const format[], ...)
\param socket: the socket
\param format[]: the message
*/
native nprintf(const socket,const format[], ...);

/*!
\funcname ncprintf
\brief Prints a message of given color to the given socket
\author Luxor
\syntax ncprintf(const socket,const color,const format[], ...)
\param socket: the socket
\param format[]: the message
*/
native ncprintf(const socket,const color,const format[], ...);

/*!
\funcname ntprintf
\brief Prints a translated message to the given socket
\author Luxor
\syntax ntprintf(const socket, const format[], ...)
\param socket: the socket
\param format[]: the message
*/
native ntprintf(const socket,const format[], ...);

/*!
\funcname sprintf
\brief Copies formatted output from format into dest
\author Sparhawk
\syntax sprintf(dest[],const format[], ...)
\param dest[]: the string to copy into
\param format[]: the string to copy
*/
native sprintf(dest[],const format[], ...);

/*!
\funcname chr_skillMakeMenu
\brief 
\author Luxor
\syntax chr_skillMakeMenu(const chr, const makeMenu, const skill)
\todo document
*/
native chr_skillMakeMenu(const chr, const makeMenu, const skill);

/*!
\funcname bypass
\brief Bypasses default server behaviour
\author Xanathar
\syntax bypass()
*/
native bypass();

/*!
\funcname setWindowTitle
\brief Sets the window title
\author Xanathar
\syntax setWindowTitle(const format[], ...)
*/
native setWindowTitle(const format[], ...);

/*!
\funcname getFrameStatus
\brief Gets the current frame status
\author Xanathar
\syntax getFrameStatus()
*/
native getFrameStatus();

/*!
\funcname addTimer
\brief Adds a new timer
\author Xanathar
\syntax addTimer(const callback, const interval, const more1 = -1, const more2 = -1)
\param callback: the function index that the timer have to call
\param interval: the interval of the timer
\deprecated old mode
*/
native addTimer(const callback, const interval, const more1 = -1, const more2 = -1);

/*!
\funcname timer_add
\brief Add a new timer
\author Endymion
\since 0.82
\param 1: the object ( item or char )
\param 2: secs
\param 3: callback eg. funcidx("callbck_func")
\param 4: flags
\param 5: n
\param 6: more1
\param 7: more2
\return none
\warning under construction
*/
native timer_add(serial, secs, check = 0, flags = 1, n = -1, more1 = 0, more2 = 0);

/** @} */ // end of script_API_nnsodove

/** \defgroup script_API_noxInfo Noxwizard information
 *  \ingroup script_API
 *  @{
 */

/*!
\funcname getNXWVersion
\brief Gets the NoX-Wizard engine version
\author Xanathar
\syntax getNXWVersion()
*/
native getNXWVersion();

/*!
\funcname getNXWVersionType
\brief Version type?
\author Xanathar
\syntax getNXWVersionType()
\todo document
*/
native getNXWVersionType();

/*!
\funcname getNXWPlatform
\brief Gets the platform which NoX-Wizard is running on
\author Xanathar
\syntax getNXWPlatform()
*/
native getNXWPlatform();

/** @} */ // end of script_API_noxInfo

/*!
\funcname getCharTarget
\brief Gets the targetted char
\author Xanathar
\syntax getCharTarget()
*/
native getCharTarget();

/*!
\funcname getItemTarget
\author Xanathar
\syntax getItemTarget()
\brief Gets the targetted item
*/
native getItemTarget();

/*!
\funcname getStringMode
\author Xanathar
\syntax getStringMode()
\brief Gets the current string mode used
*/
native getStringMode();

/*!
\funcname setStringMode
\author Xanathar
\syntax setStringMode(const mode)
\param mode: the string mode to set
\brief Sets the current string mode
*/
native setStringMode(const mode);

/*!
\funcname getCharFromSocket
\author Xanathar
\syntax getCharFromSocket(const socket)
\param socket: the socket
\brief Gets the char currently used by the given socket
*/
native getCharFromSocket(const socket);

/*!
\funcname getCharFromSerial
\author Xanathar
\syntax getCharFromSerial(const serial)
\param serial: the serial
\brief Gets the char of the given serial
\deprecated do nothing now
*/
native getCharFromSerial(const serial);

/*!
\funcname getItemFromSerial
\author Luxor
\syntax getItemFromSerial(const serial)
\param serial: the serial
\brief Gets the item of the given serial
\deprecated do nothing now
*/
native getItemFromSerial(const serial);

/*!
\funcname getSocketFromChar
\author Xanathar
\syntax getItemFromSerial(const chr)
\param chr: the character
\brief Gets the socket of the given char
*/
native getSocketFromChar(const chr);

/*!
\funcname getCurrentTime
\author Xanathar
\syntax getCurrentTime()
\brief Gets the current time
*/
native getCurrentTime();

/*!
\funcname getSystemTime
\brief get the current system time (in s)
\author Keldan
\since 0.83
\return the current system time (in s)
*/
native getSystemTime();

/*!
\funcname getTarget
\author Xanathar
\syntax getTarget(const socket, const callback, const format[], ...)
\param socket: the socket of the client in which the target will be brought up
\param callback: the function index that will be invoked by the target
\param format[]: the message that will be sent with the target
\brief Brings up a target, that will invoke the specific callback when the choice is made
*/
native getTarget(const socket, const callback, const format[], ...);

/*!
\funcname getSocketCount
\author Xanathar
\syntax getSocketCount()
\brief Gets the number of sockets connected
*/
native getSocketCount();

/*!
\funcname cfgServerOption
\author Xanathar
\syntax cfgServerOption(const format[], ...)
\param format[]: the CFG command to be executed
\brief Performs a CFG command configuring a server.scp entry
*/
native cfgServerOption(const format[], ...);

/*!
\funcname weblaunch
\author Luxor
\syntax weblaunch(const socket,const format[], ...)
\param socket: the socket
\param format[]: the URL to be opened by the web client
\brief Sends a request to the given socket to launch its web client
*/
native weblaunch(const socket,const format[], ...);

/*!
\funcname broadcast
\author Luxor
\syntax broadcast(const format[], ...)
\param format[]: the message to broadcast
\brief Sends a broadcast message
*/
native broadcast(const format[], ...);

/*!
\funcname getCurrentSocket
\brief get current socket
\author Xanathar
\since 0.10
\return the socket, if error is INVALID
\deprecated not secure, very
*/
native getCurrentSocket();

/*!
\funcname var_get
\brief New amx variable interface (work in progress so don't touch)
\author Sparhawk
\since 0.82
\return To be explained
\note Replacement for itm/chr get/set Local var
*/
native var_get(const serial, const var, string[]);

/*************************************************************************
 DIRECT NATIVE FUNCTIONS
 *************************************************************************/

/** \defgroup script_API_direct Direct Native functions
 *  \ingroup script_API
 *  @{
 */
 
/*!
\funcname direct_target
\brief
\author Xanathar
\syntax direct_target(const socket, a1, a2, a3, a4, const format[], ...)
\todo document
*/
native direct_target(const socket, a1, a2, a3, a4, const format[], ...);

/*!
\funcname direct_castSpell
\brief
\author Xanathar
\syntax direct_castSpell(const socket)
\todo document
*/
native direct_castSpell(const socket);

/*!
\funcname direct_setSpellType
\brief
\author Xanathar
\syntax direct_setSpellType(const socket, const type)
\todo document
*/
native direct_setSpellType(const socket, const type);

/** @} */ // end of script_API_direct

/*************************************************************************
 TRIGGER RELATED FUNCTIONS
 *************************************************************************/


/** \defgroup script_API_trigger Trigger related functions
 *  \ingroup script_API
 *  @{
 */
 
/*!
\funcname trig_getTItem
\brief
\author Xanathar
\syntax trig_getTItem()
\todo document
*/
native trig_getTItem();

/*!
\funcname trig_getTrigType
\brief
\author Xanathar
\syntax trig_getTrigType()
\todo document
*/
native trig_getTrigType();

/** @} */ // end of script_API_trigger


/**
 * \defgroup script_API_obj Object
 * \ingroup script_API
 * Object
 */


/*************************************************************************
 CHARACHTER RELATED PROTOTYPES
 *************************************************************************/

/** \defgroup script_API_chr_privileges Privileges
 *  \ingroup script_API_chr
 *  @{
 */
 
/*!
\funcname chr_getPriv
\brief
\author Xanathar
\syntax chr_getPriv(const chr)
*/
native chr_getPriv(const chr);
 
/*!
\funcname chr_canBroadcast
\brief
\author Xanathar
\syntax chr_canBroadcast(const chr)
*/
native chr_canBroadcast(const chr);

/*!
\funcname chr_canSeeSerials
\brief
\author Xanathar
\syntax chr_canSeeSerials(const chr)
*/
native chr_canSeeSerials(const chr);

/*!
\funcname chr_canSnoop
\brief
\author Xanathar
\syntax chr_canSnoop(const chr)
*/
native chr_canSnoop(const chr);

/*!
\funcname chr_isCounselor
\brief
\author Xanathar
\syntax chr_isCounselor(const chr)
*/
native chr_isCounselor(const chr);

/*!
\funcname chr_isCriminal
\brief
\author Xanathar
\syntax chr_isCriminal(const chr)
*/
native chr_isCriminal(const chr);

/*!
\funcname chr_isGM
\brief
\author Xanathar
\syntax chr_isGM(const chr)
*/
native chr_isGM(const chr);

/*!
\funcname chr_isGMorCns
\brief
\author Xanathar
\syntax chr_isGMorCns(const chr)
*/
native chr_isGMorCns(const chr);

/*!
\funcname chr_isGrey
\brief
\author Xanathar
\syntax chr_isGrey(const chr)
*/
native chr_isGrey(const chr);

/*!
\funcname chr_isHuman
\brief
\author Xanathar
\syntax chr_isHuman(const chr)
*/
native chr_isHuman(const chr);

/*!
\funcname chr_isInnocent
\brief
\author Xanathar
\syntax chr_isInnocent(const chr)
*/
native chr_isInnocent(const chr);

/*!
\funcname chr_isInvul
\brief
\author Xanathar
\syntax chr_isInvul(const chr)
*/
native chr_isInvul(const chr);

/*!
\funcname chr_isMurderer
\brief
\author Xanathar
\syntax chr_isMurderer(const chr)
*/
native chr_isMurderer(const chr);

/*!
\funcname chr_isTrueGM
\brief
\author Xanathar
\syntax chr_isTrueGM(const chr)
*/
native chr_isTrueGM(const chr);


/** @} */ // end of script_API_chr_privileges

/** \defgroup script_API_chr Character
 *  \ingroup script_API_obj
 *  @{
 */
 

/*!
\funcname chr_getProperty
\brief 
\author Xanathar
\syntax chr_getProperty(const chr, const property, const subprop=0, ...)
\todo document
*/
native chr_getProperty(const chr, const property, const subprop=0, ...);

/*!
\funcname chr_setProperty
\brief
\author Xanathar
\syntax chr_setProperty(const chr, const property, const subprop=0, ...)
\todo document
*/
native chr_setProperty(const chr, const property, const subprop=0, ...);


/*!
\funcname chr_countBankGold
\author Xanathar
\syntax chr_countBankGold(const chr)
\brief
*/
native chr_countBankGold(const chr);

/*!
\funcname chr_countGold
\author Xanathar
\syntax chr_countGold(const chr)
\brief
*/
native chr_countGold(const chr);

/*!
\funcname chr_countItems
\author Xanathar
\syntax chr_countItems(const chr, const itemtype, const color = -1)
\brief
*/
native chr_countItems(const chr, const itemtype, const color = -1);

/*!
\funcname chr_disturbMed
\author Xanathar
\syntax chr_disturbMed(const chr)
\brief
*/
native chr_disturbMed(const chr);

/*!
\funcname chr_getBankBox
\author Xanathar
\syntax chr_getBankBox(const chr, const bankboxtype)
\brief
*/
native chr_getBankBox(const chr, const bankboxtype);

/*!
\funcname chr_getItemOnLayer
\author Xanathar
\syntax chr_getItemOnLayer(const chr, const layer)
\brief
*/
native chr_getItemOnLayer(const chr, const layer);

/*!
\funcname chr_getShield
\author Xanathar
\syntax chr_getShield(const chr)
\brief
*/
native chr_getShield(const chr);

/*!
\funcname chr_getWeapon
\author Xanathar
\syntax chr_getWeapon(const chr)
\brief
*/
native chr_getWeapon(const chr);


/*!
\funcname chr_makeInvul
\author Xanathar
\syntax chr_makeInvul(const chr)
\brief
*/
native chr_makeInvul(const chr);

/*!
\funcname chr_makeVulnerable
\author Xanathar
\syntax chr_makeVulnerable(const chr)
\brief
*/
native chr_makeVulnerable(const chr);

/*!
\funcname chr_moveTo
\author Xanathar
\syntax chr_moveTo(const chr, const x, const y, const z)
\brief
*/
native chr_moveTo(const chr, const x, const y, const z);

/*!
\funcname chr_setCriminal
\author Xanathar
\syntax chr_setCriminal(const chr)
\brief
*/
native chr_setCriminal(const chr);

/*!
\funcname chr_setGrey
\author Xanathar
\syntax chr_setGrey(const chr)
\brief
*/
native chr_setGrey(const chr);

/*!
\funcname chr_setPermaGrey
\author Xanathar
\syntax chr_setPermaGrey(const chr)
\brief
*/
native chr_setPermaGrey(const chr);

/*!
\funcname chr_setInnocent
\author Xanathar
\syntax chr_setInnocent(const chr)
\brief
*/
native chr_setInnocent(const chr);

/*!
\funcname chr_setMurderer
\author Xanathar
\syntax chr_setMurderer(const chr)
\brief
*/
native chr_setMurderer(const chr);

/*!
\funcname chr_setPriv
\author Xanathar
\syntax chr_setPriv(const chr, const priv)
\brief
*/
native chr_setPriv(const chr, const priv);

/*!
\funcname chr_unhide
\author Xanathar
\syntax chr_unhide(const chr)
\brief
*/
native chr_unhide(const chr);

/*!
\funcname chr_setMultiSerial
\author Xanathar
\syntax chr_setMultiSerial(const chr, const serial)
\brief
*/
native chr_setMultiSerial(const chr, const serial);

/*!
\funcname chr_setOwnSerial
\author Xanathar
\syntax chr_setOwnSerial(const chr, const serial)
\brief
*/
native chr_setOwnSerial(const chr, const serial);

/*!
\funcname chr_setOwnSerOnly
\author Xanathar
\syntax chr_setOwnSerOnly(const chr, const serial)
\brief
*/
native chr_setOwnSerOnly(const chr, const serial);

/*!
\funcname chr_checkEquipment
\author Xanathar
\syntax chr_checkEquipment(const chr)
\brief
*/
native chr_checkEquipment(const chr);

/*!
\funcname chr_spawnIteminBank
\author Xanathar
\syntax chr_spawnIteminBank(const chr, const itemid)
\brief
*/
native chr_spawnIteminBank(const chr, const itemid);

/*!
\funcname chr_addNPC
\author Xanathar
\syntax chr_addNPC(const npcnum, const x, const y, const z)
\brief
*/
native chr_addNPC(const npcnum, const x, const y, const z);

/*!
\funcname chr_remove
\author Xanathar
\syntax chr_remove(const chr)
\brief
*/
native chr_remove(const chr);

/*!
\funcname chr_calcAtt
\author Xanathar
\syntax chr_calcAtt(const chr)
\brief
*/
native chr_calcAtt (const chr);

/*!
\funcname chr_calcDef
\author Xanathar
\syntax chr_calcDef(const chr)
\brief
*/
native chr_calcDef (const chr);

/*!
\funcname chr_fish
\author Xanathar
\syntax chr_fish(const chr)
\brief
*/
native chr_fish (const chr);

/*!
\funcname chr_getGuild
\author Sparhawk
\since 0.82.rc3
\syntax chr_getGuild( const chr )
\brief Get guild serial for new guild system
*/
native chr_getGuild( const chr );


/*!
\funcname chr_guildCompare
\author Xanathar
\syntax chr_guildCompare(const chr1, const chr2)
\brief
*/
native chr_guildCompare (const chr1, const chr2);

/*!
\funcname chr_attackStuff
\author Xanathar
\syntax chr_attackStuff(const chr_defender, const socket_attacker)
\brief
*/
native chr_attackStuff (const chr_defender, const socket_attacker);

/*!
\funcname chr_helpStuff
\author Xanathar
\syntax chr_helpStuff(const chr_target, const socket_helper)
\brief
*/
native chr_helpStuff (const chr_target, const socket_helper);

/*!
\funcname chr_action
\author Xanathar
\syntax chr_action(const chr, const action)
\brief
*/
native chr_action (const chr, const action);

/*!
\funcname chr_checkSkill
\author Xanathar
\syntax chr_checkSkill(const chr, const skill, const min=0, const max=1000, const raise=1)
\brief
*/
native chr_checkSkill(const chr, const skill, const min=0, const max=1000, const raise=1);

/*!
\funcname chr_unmountHorse
\author Xanathar
\syntax chr_unmountHorse(const chr)
\brief
*/
native chr_unmountHorse(const chr);

/*!
\funcname chr_mountHorse
\author Xanathar
\syntax chr_mountHorse(const chr, const horse_chr)
\brief
*/
native chr_mountHorse(const chr, const horse_chr);

/*!
\funcname chr_resurrect
\author Xanathar
\syntax chr_resurrect(const chr)
\brief
*/
native chr_resurrect(const chr);

/*!
\funcname chr_sound
\author Xanathar
\syntax chr_sound(const chr, const soundfx)
\brief
*/
native chr_sound(const chr, const soundfx);

/*!
\funcname chr_distance
\author Xanathar
\syntax chr_distance(const chr1, const chr2)
\brief
*/
native chr_distance(const chr1, const chr2);

/*!
\funcname chr_npcAttack
\author Luxor
\syntax chr_npcAttack(const attacker, const target)
\brief
*/
native chr_npcAttack(const attacker, const target);

/*!
\funcname chr_update
\author Luxor
\syntax chr_update(const chr)
\brief
*/
native chr_update(const chr);

/*!
\funcname chr_npcRelease
\author Luxor
\syntax chr_npcRelease(const chr)
\brief
*/
native chr_npcRelease(const chr);

/*!
\funcname chr_owns
\author Luxor
\syntax chr_owns(const chr1, const chr2)
\brief
*/
native chr_owns(const chr1, const chr2);

/*!
\funcname chr_speech
\author Sparhawk
\syntax chr_speech(const function, const chr = -1, const npc, const text[], const antispam = 1)
\brief
*/
native chr_speech(const function, const chr = -1, const npc, const text[], const antispam = 1);

/*!
\funcname chr_teleport
\author Luxor
\syntax chr_teleport(const chr)
\brief
*/
native chr_teleport(const chr);

/*!
\funcname chr_lineOfSight
\author Luxor
\syntax chr_lineOfSight(const s, const x1, const y1, const z1, const x2, const y2, const z2, const checkfor)
\brief
*/
native chr_lineOfSight(const s, const x1, const y1, const z1, const x2, const y2, const z2, const checkfor);

/*!
\funcname chr_poison
\author Luxor
\syntax chr_poison(const chr, const poisontype, const secs = -1)
\brief
*/
native chr_poison(const chr, const poisontype, const secs = -1);

/*!
\funcname chr_hide
\author Luxor
\syntax chr_hide(const chr, const hidden)
\brief
*/
native chr_hide(const chr, const hidden);

/*!
\funcname chr_applyDamage
\author Luxor
\syntax chr_applyDamage(const chr, const damage, const damagetype, const stattobedamaged)
\brief
*/
native chr_applyDamage(const chr, const damage, const damagetype, const stattobedamaged);

/*!
\funcname chr_setRandomName
\author Luxor
\syntax chr_setRandomName(const chr, const namelist[])
\brief
*/
native chr_setRandomName(const chr, const namelist[]);

/*!
\funcname chr_showMessage
\author Sparhawk
\syntax (const showToWhom, const showWhom, const msg[], const color = 0x0481)
\brief
*/
native chr_showMessage(const showToWhom, const showWhom, const msg[], const color = 0x0481);

/*!
\funcname chr_getGuildType
\author Sparhawk
\syntax chr_getGuildType(const chr)
\brief
*/
native chr_getGuildType( const chr );

/*!
\funcname chr_setGuildType
\author Sparhawk
\syntax chr_setGuildType(const chr, const type)
\brief
*/
native chr_setGuildType( const chr, const type );

/*!
\funcname chr_isGuildTraitor
\author Sparhawk
\syntax chr_isGuildTraitor(const chr)
\brief
*/
native chr_isGuildTraitor( const chr );

/*!
\funcname chr_setGuildTraitor
\author Sparhawk
\syntax chr_setGuildTraitor(const chr, const traitor = 1)
\brief
*/
native chr_setGuildTraitor( const chr, const traitor = 1 );

/*!
\funcname chr_hasGuildToggle
\author Sparhawk
\syntax chr_hasGuildToggle(const chr)
\brief
*/
native chr_hasGuildToggle( const chr );

/*!
\funcname chr_setGuildToggle
\author Sparhawk
\syntax chr_setGuildToggle(const chr, const toggle = 1)
\brief
*/
native chr_setGuildToggle( const chr, const toggle = 1 );

/*!
\funcname chr_getGuildFealty
\author Sparhawk
\syntax chr_getGuildFealty(const chr)
\brief
*/
native chr_getGuildFealty( const chr );

/*!
\funcname chr_setGuildFealty
\author Sparhawk
\syntax chr_setGuildFealty(const chr, const fealty)
\brief
*/
native chr_setGuildFealty( const chr, const fealty );

/*!
\funcname chr_getGuildNumber
\author Sparhawk
\syntax chr_getGuildNumber(const chr)
\brief
*/
native chr_getGuildNumber( const chr );

/*!
\funcname chr_setGuildNumber
\author Sparhawk
\syntax chr_setGuildNumber(const chr)
\brief
*/
native chr_setGuildNumber( const chr, const number );

/*!
\funcname chr_getGuildTitle
\author Sparhawk
\syntax chr_getGuildTitle(const chr, title[])
\brief
*/
native chr_getGuildTitle( const chr, title[] );

/*!
\funcname chr_setGuildTitle
\author Sparhawk
\syntax chr_setGuildTitle(const chr, const title[])
\brief
*/
native chr_setGuildTitle( const chr, const title[] );

/*!
\funcname chr_getCreationDay
\author Sparhawk
\syntax chr_getCreationDay(const chr)
\brief
*/
native chr_getCreationDay( const chr );

/*!
\funcname chr_setCreationDay
\author Sparhawk
\syntax chr_setCreationDay(const chr, const day)
\brief
*/
native chr_setCreationDay( const chr, const day );

/*!
\funcname chr_morph
\author Luxor
\syntax chr_morph(const chr, const bodyid, const skincolor, const hairstyle, const haircolor, const beardstyle, const beardcolor, const backup, const format[], ...)
\brief
*/
native chr_morph( const chr, const bodyid, const skincolor, const hairstyle, const haircolor, const beardstyle, const beardcolor, const backup, const format[], ... );

/*!
\funcname chr_unmorph
\author Luxor
\syntax chr_unmorph(const chr)
\brief
*/
native chr_unmorph( const chr );

/*!
\funcname chr_possess
\author Keldan
\syntax chr_possess(const possessor, const possessed)
\brief made "possessor" character possess "possessed" character. Possessor can't be NPC.
*/
native chr_possess(const possessor, const possessed);

/** @} */ // end of script_API_chr

/** \defgroup script_API_chr_event Event
 *  \ingroup script_API_chr
 *  @{
 */

/*!
\funcname chr_getEventHandler
\author Sparhawk
\syntax chr_getEventHandler(const chr, const event, handler[])
\param chr:	character serial
\param event:	character event identifier (EVENT_CHR_ON*)
\brief Returns name of small function bound to the specified event into handler
*/
native chr_getEventHandler(const chr, const event, handler[]);

/*!
\funcname chr_setEventHandler
\author Xanathar
\syntax chr_setEventHandler(const chr, const event, const evtype, const format[], ...)
\param chr:	character serial
\param event:	character event identifier (EVENT_CHR_ON*)
\param evtype:	sets dynamic or static event type (EVENTTYPE_STATIC or EVENTTYPE_DYNAMIC). Static events will be saved in worldfile.
\param format:	Name of small function to bind to the event
\brief Binds a small function to a character event
*/
native chr_setEventHandler(const chr, const event, const evtype, const format[], ...);

/*!
\funcname chr_delEventHandler
\author Xanathar
\syntax chr_delEventHandler(const chr, const event)
\param chr:	character serial
\param event:	character event identifier (EVENT_CHR_ON*)
\brief Unbinds link between a character event and a small function
*/
native chr_delEventHandler(const chr, const event);

/** @} */ // end of script_API_chr_event


/** \defgroup script_API_chr_amxvar Amx Var
 *  \ingroup script_API_chr
 *  @{
 */


/*!
\funcname chr_getLocalVarErr
\author Sparhawk
\syntax chr_getLocalVarErr()
\brief Returns result for all operations on character variables
\brief Returned value is one of VAR_ERROR_NONE, VAR_ERROR_UNKNOWN_VAR, VAR_ERROR_DUPLICATE_VAR, VAR_ERROR_WRONG_TYPE, VAR_ERROR_ACCESS_DENIED
*/
native chr_getLocalVarErr();

/*!
\funcname chr_isaLocalVar
\author Sparhawk
\syntax chr_isaLocalVar(const chr, const var, const type = 0)
\param chr:	character serial
\param var:	variable identifier
\param type:	type of variable (VAR_TYPE_ANY, VAR_TYPE_INTEGER, VAR_TYPE_STRING )
\brief Returns true when variable exists for character. Can also be used to check wether variable is of a specific type
*/
native chr_isaLocalVar( const chr, const var, const type = 0 );

/*!
\funcname chr_sizeofLocalVar
\author Sparhawk
\syntax chr_sizeofLocalVar( const serial, const var, const index = -1 )
\brief Returns length of a local variable, number of elements in a vector, or length of variable in a vector
*/
native chr_sizeofLocalVar( const serial, const var, const index = -1 );

/*!
\funcname chr_delLocalVar
\author Sparhawk
\syntax chr_delLocalVar(const chr, const var, const type = 0)
\param chr:	character serial
\param var:	variable identifier
\param type:	type of variable (VAR_TYPE_ANY, VAR_TYPE_INTEGER, VAR_TYPE_STRING )
\brief Deletes character variable. When type is not VAR_TYPE_ANY variable is only deleted if of same type as specified.
*/
native chr_delLocalVar( const chr, const var, const type = 0 );

/*!
\funcname chr_addLocalIntVar
\author Sparhawk
\syntax chr_addLocalIntVar(const chr, const var, const value = 0)
\param chr:	character serial
\param var:	variable identifier
\param value:	initial value
\brief Adds a new integer variable to the character
*/
native chr_addLocalIntVar( const chr, const var, const value = 0 );

/*!
\funcname chr_getLocalIntVar
\author Sparhawk
\syntax chr_getLocalIntVar(const chr, const var)
\param chr:	character serial
\param var:	variable identifier
\brief Get value of specified integer variable from character
*/
native chr_getLocalIntVar( const chr, const var );

/*!
\funcname chr_setLocalIntVar
\author Sparhawk
\syntax chr_setLocalIntVar(const chr, const var, const value = 0)
\param chr:	character serial
\param var:	variable identifier
\param value:	new value
\brief Set the value of specified integer variable for the character
*/
native chr_setLocalIntVar( const chr, const var, const value = 0 );

/*!
\funcname chr_addLocalIntVec
\author Sparhawk
\syntax chr_addLocalIntVec(const chr, const var, const size = 1, const value = 0)
\param chr:	character serial
\param var:	variable identifier
\param size	number of array elements
\param value:	initial value
\brief Adds a new integer variable array to the character
*/
native chr_addLocalIntVec( const chr, const var, const size = 1, const value = 0 );

/*!
\funcname chr_getLocalIntVec
\author Sparhawk
\syntax chr_getLocalIntVec(const chr, const var, const index = 0)
\param chr:	character serial
\param var:	variable identifier
\param index:	0 based index into array
\brief Get value of specified integer variable from character
*/
native chr_getLocalIntVec( const chr, const var, const index = 0);

/*!
\funcname chr_setLocalIntVec
\author Sparhawk
\syntax chr_setLocalIntVec(const chr, const var, const index = 0, const value = 0)
\param chr:	character serial
\param var:	variable identifier
\param index:	0 based index into array
\param value:	new value
\brief Set the value of specified integer variable for the character
*/
native chr_setLocalIntVec( const chr, const var, const index = 0, const value = 0 );

/*!
\funcname chr_addLocalStrVar
\author Sparhawk
\syntax chr_addLocalStrVar(const chr, const var, const value[] = "")
\param chr:	character serial
\param var:	variable identifier
\param value:	initial value
\brief Adds a new string variable to the character
*/
native chr_addLocalStrVar( const chr, const var, const value[] = "" );

/*!
\funcname chr_getLocalStrVar
\author Sparhawk
\syntax chr_getLocalStrVar(const chr, const var, value[])
\param chr:	character serial
\param var:	variable identifier
\brief Get value of specified string variable from character into value.
*/
native chr_getLocalStrVar( const chr, const var, value[] );

/*!
\funcname chr_setLocalStrVar
\author Sparhawk
\syntax chr_setLocalStrVar(const chr, const var, const value[] = "")
\param chr:	character serial
\param var:	variable identifier
\param value:	new value
\brief Set the value of specified string variable for the character
*/
native chr_setLocalStrVar( const chr, const var, const value[] = "" );

/*!
\funcname chr_countLocalVar
\author Sparhawk
\syntax chr_countLocalVar(const chr)
\param chr:	character serial
\return number of variables defined
\brief Count the number of local variables defined for specified character
*/
native chr_countLocalVar( const chr );

/*!
\funcname chr_firstLocalVar
\author Sparhawk
\syntax chr_firstLocalVar(const chr)
\param chr:	character serial
\return first defined local variable or INVALID
\brief get id of first defined local variable
*/
native chr_firstLocalVar( const chr );

/*!
\funcname chr_nextLocalVar
\author Sparhawk
\syntax chr_nextLocalVar(const chr, const previous)
\param chr:	character serial
\param previous: variable id of previous variable
\return next defined local variable or INVALID
\brief get id of next defined local variable
*/
native chr_nextLocalVar( const chr, const previous );

/** @} */ // end of script_API_chr_amxvar



/*************************************************************************
 ITEM RELATED PROTOTYPES
 *************************************************************************/
 
/** \defgroup script_API_item Item
 *  \ingroup script_API_obj
 *  @{
 */

/*!
\funcname itm_getProperty
\author Xanathar
\syntax itm_getProperty(const item, const property, const subprop=0, ...)
\brief
*/
native itm_getProperty(const item, const property, const subprop=0, ...);

/*!
\funcname itm_setProperty
\author Xanathar
\syntax itm_setProperty(const item, const property, const subprop=0, ...)
\brief
*/
native itm_setProperty(const item, const property, const subprop=0, ...);

/*!
\funcname itm_contAddItem
\author Xanathar
\syntax itm_contAddItem(const container, const item, const x, const y)
\brief
*/
native itm_contAddItem(const container, const item, const x, const y);

/*!
\funcname itm_color
\author Xanathar
\syntax itm_color(const item)
\brief
*/
native itm_color(const item);

/*!
\funcname itm_contPileItem
\author Xanathar
\syntax itm_contPileItem(const container, const item)
\brief
*/
native itm_contPileItem(const container, const item);

/*!
\funcname itm_contCountItems
\author Xanathar
\syntax itm_contCountItems(const container, const id, const color = -1)
\brief
*/
native itm_contCountItems(const container, const id, const color = -1);

/*!
\funcname itm_countItemsByID
\author Keldan
\syntax itm_countItemsByID(const container, const ScriptID)
\brief return amount of items identified by ScriptID
*/
native itm_countItemsByID(const container, const ScriptID);

/*!
\funcname itm_contDelAmount
\author Xanathar
\syntax itm_contDelAmount(const container, const amount, const id, const color = -1)
\brief
*/
native itm_contDelAmount(const container, const amount, const id, const color = -1);

/*!
\funcname itm_delAmountByID
\author Keldan
\syntax itm_delAmountByID(const container, const amount, const ScriptID)
\brief remove from container "amount" number of items, identified by ScriptID
*/
native itm_delAmountByID(const container, const amount, const ScriptID);

/*!
\funcname itm_moveTo
\author Xanathar
\syntax itm_moveTo(const item, const x, const y, const z)
\brief
*/
native itm_moveTo(const item, const x, const y, const z);

/*!
\funcname itm_pileItem
\author Xanathar
\syntax itm_pileItem(const container, const item)
\brief
*/
native itm_pileItem(const container, const item);

/*!
\funcname itm_reduceAmount
\author Xanathar
\syntax itm_reduceAmount(const item, const amount)
\brief
*/
native itm_reduceAmount(const item, const amount);

/*!
\funcname itm_setContSerial
\author Xanathar
\syntax itm_setContSerial(const item, const serial)
\brief
*/
native itm_setContSerial(const item, const serial);

/*!
\funcname itm_setContSerOnly
\author Xanathar
\syntax itm_setContSerOnly(const item, const serial)
\brief
*/
native itm_setContSerOnly(const item, const serial);

/*!
\funcname itm_setMultiSerial
\author Xanathar
\syntax itm_setMultiSerial(const item, const serial)
\brief
*/
native itm_setMultiSerial(const item, const serial);

/*!
\funcname itm_setOwnSerial
\author Xanathar
\syntax itm_setOwnSerial(const item, const serial)
\brief
*/
native itm_setOwnSerial(const item, const serial);

/*!
\funcname itm_setOwnSerOnly
\author Xanathar
\syntax itm_setOwnSerOnly(const item, const serial)
\brief
*/
native itm_setOwnSerOnly(const item, const serial);

/*!
\funcname itm_setSerial
\author Xanathar
\syntax itm_setSerial(const item, const serial)
\brief
*/
native itm_setSerial(const item, const serial);

/*!
\funcname itm_spawnBackpack
\author Xanathar
\syntax itm_spawnBackpack(const socket, const itemid)
\brief
*/
native itm_spawnBackpack(const socket, const itemid);

/*!
\funcname itm_getCharBackPack
\author Xanathar
\syntax itm_getCharBackPack(const chr)
\brief
*/
native itm_getCharBackPack(const chr);

/*!
\funcname itm_create
\author Xanathar
\syntax itm_create(const itemtype)
\brief
*/
native itm_create(const itemtype);

/*!
\funcname itm_spawnBank
\author Xanathar
\syntax itm_spawnBank(const socket, const itemid)
\brief
*/
native itm_spawnBank(const socket, const itemid);

/*!
\funcname itm_checkDecay
\author Xanathar
\syntax itm_checkDecay(const item)
\brief
*/
native itm_checkDecay(const itm);

/*!
\funcname itm_remove
\author Xanathar
\syntax itm_remove(const item)
\brief
*/
native itm_remove(const itm);

/*!
\funcname itm_getEventHandler
\author Sparhawk
\syntax itm_getEventHandler(const chr, const event, handler[])
\param itm:	item serial
\param event:	item event identifier (EVENT_ITM_ON*)
\brief Returns name of small function bound to the specified event into handler
*/
native itm_getEventHandler(const chr, const event, handler[]);

/*!
\funcname itm_setEventHandler
\author Xanathar
\syntax itm_setEventHandler(const itm, const event, const evtype, const format[], ...)
\param itm:	item serial
\param event:	item event identifier (EVENT_ITM_ON*)
\param evtype:	sets dynamic or static event type (EVENTTYPE_STATIC or EVENTTYPE_DYNAMIC). Static events will be saved in worldfile.
\param format:	Name of small function to bind to the event
\brief Binds small function name to the specified event.
*/
native itm_setEventHandler(const itm, const event, const evtype, const format[], ...);

/*!
\funcname itm_delEventHandler
\author Xanathar
\syntax itm_delEventHandler(const item, const event)
\param itm:	item serial
\param event:	item event identifier (EVENT_ITM_ON*)
\brief Unbinds link between small function an item event
*/
native itm_delEventHandler(const itm, const event);

/*!
\funcname itm_sound
\author Xanathar
\syntax itm_sound(const item, const soundfx)
\brief
*/
native itm_sound(const itm, const soundfx);

/*!
\funcname itm_spawnItem
\author Luxor
\syntax itm_spawnItem(const s, const chr, const amount, const format[], const stackable, const cItemId1, const cItemId2, const cColorId1, const cColorId2, const pack, const send)
\brief
*/
native itm_spawnItem(const s, const chr, const amount, const format[], const stackable, const cItemId1, const cItemId2, const cColorId1, const cColorId2, const pack, const send);

/*!
\funcname itm_spawnNecroItem
\author Luxor
\syntax itm_spawnNecroItem(const s, const inPack, const format[])
\brief
*/
native itm_spawnNecroItem(const s, const inPack, const format[]);

/*!
\funcname itm_refresh
\author Luxor
\syntax itm_refresh(const item)
\brief
*/
native itm_refresh(const itm);

/*!
\funcname itm_speech
\author Anthalir
\syntax itm_speech(const s, const itm, const text[])
\brief
*/
native itm_speech(const s, const itm, const text[]);

/*!
\funcname itm_equip
\author Anthalir
\syntax itm_equip(const chr, const item)
\brief
*/
native itm_equip(const chr, const item);

/*!
\funcname itm_bounceToPack
\author Anthalir
\syntax itm_bounceToPack(const s, const item)
\brief
*/
native itm_BounceToPack(const s, const item);

/*!
\funcname itm_getLocalVarErr
\author Sparhawk
\syntax itm_getLocalVarErr()
\brief Returns result for all operations on item variables
\brief Returned value is one of VAR_ERROR_NONE, VAR_ERROR_UNKNOWN_VAR, VAR_ERROR_DUPLICATE_VAR, VAR_ERROR_WRONG_TYPE, VAR_ERROR_ACCESS_DENIED
*/
native itm_getLocalVarErr();

/*!
\funcname itm_isaLocalVar
\author Sparhawk
\syntax itm_isaLocalVar(const item, const var, const type = 0)
\param item:	item serial
\param var:	variable identifier
\param type:	type of variable (VAR_TYPE_ANY, VAR_TYPE_INTEGER, VAR_TYPE_STRING )
\brief Returns true when variable exists for item. Can also be used to check wether variable is of a specific type
*/
native itm_isaLocalVar( const item, const var, const type = 0 );

/*!
\funcname itm_delLocalVar
\author Sparhawk
\syntax itm_delLocalVar(const item, const var, const type = 0)
\param item:	item serial
\param var:	variable identifier
\param type:	type of variable (VAR_TYPE_ANY, VAR_TYPE_INTEGER, VAR_TYPE_STRING )
\brief Deletes item variable. When type is not VAR_TYPE_ANY variable is only deleted if of same type as specified.
*/
native itm_delLocalVar( const item, const var, const type = 0 );

/*!
\funcname itm_addLocalIntVar
\author Sparhawk
\syntax itm_addLocalIntVar(const item, const var, const value = 0)
\param item:	item serial
\param var:	variable identifier
\param value:	initial value
\brief Adds a new integer variable to the item
*/
native itm_addLocalIntVar( const item, const var, const value = 0 );

/*!
\funcname itm_getLocalIntVar
\author Sparhawk
\syntax itm_getLocalIntVar(const item, const var)
\param item:	item serial
\param var:	variable identifier
\brief Get value of specified integer variable from item.
*/
native itm_getLocalIntVar( const itm, const var );

/*!
\funcname itm_setLocalIntVar
\author Sparhawk
\syntax itm_setLocalIntVar(const item, const var, const value = 0)
\param item:	item serial
\param var:	variable identifier
\param value:	new value
\brief Set the value of specified integer variable for the item
*/
native itm_setLocalIntVar( const itm, const var, const value = 0 );

/*!
\funcname itm_addLocalStrVar
\author Sparhawk
\syntax itm_addLocalStrVar(const item, const var, const value[] = "")
\param item:	item serial
\param var:	variable identifier
\param value:	initial value
\brief Adds a new string variable to the item
*/
native itm_addLocalStrVar( const item, const var, const value[] = "" );

/*!
\funcname itm_getLocalStrVar
\author Sparhawk
\syntax itm_getLocalStrVar(const item, const var, value[])
\param item:	item serial
\param var:	variable identifier
\brief Get value of specified string variable from item into value.
*/
native itm_getLocalStrVar( const item, const var, value[] );

/*!
\funcname itm_setLocalStrVar
\author Sparhawk
\syntax itm_setLocalStrVar(const item, const var, const value[] = "")
\param item:	item serial
\param var:	variable identifier
\param value:	new value
\brief Set the value of specified string variable for the item
*/
native itm_setLocalStrVar( const item, const var, const value[] = "" );

/*!
\funcname itm_countLocalVar
\author Sparhawk
\syntax itm_countLocalVar(const item)
\param item:	item serial
\return number of variables defined
\brief Count the number of local variables defined for specified item
*/
native itm_countLocalVar( const item );

/*!
\funcname itm_firstLocalVar
\author Sparhawk
\syntax itm_firstLocalVar(const item)
\param item:	item serial
\return first defined local variable or INVALID
\brief get id of first defined local variable
*/
native itm_firstLocalVar( const item );

/*!
\funcname itm_nextLocalVar
\author Sparhawk
\syntax itm_nextLocalVar(const item, const previous)
\param item:	item serial
\param previous: variable id of previous variable
\return next defined local variable or INVALID
\brief get id of next defined local variable
*/
native itm_nextLocalVar( const item, const previous );

/*!
\funcname itm_getCombatSkill
\author Luxor
\syntax itm_getCombatSkill(const itm)
\brief
*/
native itm_getCombatSkill(const itm);

/** @} */ // end of script_API_item

/*************************************************************************
 MENU RELATED PROTOTYPES
 *************************************************************************/

/** \defgroup script_API_manu Menu
 *  \ingroup script_API
 *  @{
 */


/*!
\funcname mnu_prepare
\author Xanathar
\syntax mnu_prepare(const socket, const pages, const itemperpage)
\brief
*/
native mnu_prepare(const socket, const pages, const itemperpage);

/*!
\funcname mnu_setStyle
\author Xanathar
\syntax mnu_setStyle(const socket, const style, const color = 0)
\brief
*/
native mnu_setStyle(const socket, const style, const color = 0);

/*!
\funcname mnu_setTitle
\author Xanathar
\syntax mnu_setTitle(const socket, const format[], ...)
\brief
*/
native mnu_setTitle(const socket, const format[], ...);

/*!
\funcname mnu_setColor
\author Xanathar
\syntax mnu_setColor(const socket, const color)
\brief
*/
native mnu_setColor(const socket, const color);

/*!
\funcname mnu_addItem
\author Xanathar
\syntax mnu_addItem(const socket, const page, const idx, const format[], ...)
\brief
*/
native mnu_addItem(const socket, const page, const idx, const format[], ...);

/*!
\funcname mnu_show
\author Xanathar
\syntax mnu_show(const socket)
\brief
*/
native mnu_show(const socket);

/*!
\funcname mnu_setCallback
\author Xanathar
\syntax mnu_setCallback(const socket, const callback)
\brief
*/
native mnu_setCallback(const socket, const callback);

/** @} */ // end of script_API_menu


/*************************************************************************
 MAGIC RELATED PROTOTYPES
 *************************************************************************/

/** \defgroup script_API_magic Magic
 *  \ingroup script_API
 *  @{
 */

/*!
\funcname magic_cast
\author Endymion
\syntax magic_cast(const chr_caster, const chr_target, const spell)
\brief
*/

native magic_cast(const chr_caster, const chr_target, const spell);
/*!
\funcname magic_castField
\author Xanathar
\syntax magic_castField(const chr_caster, const x, const y, const z, const fieldtype)
\brief
*/

native magic_castField(const chr_caster, const x, const y, const z, const fieldtype);

/*!
\funcname magic_chkSpellbook
\author Xanathar
\syntax magic_chkSpellbook(const itm_spellbook,const circle, const spell)
\brief
*/
native magic_chkSpellbook(const itm_spellbook,const circle, const spell);

/*!
\funcname magic_chkMagicRef
\author Xanathar
\syntax magic_chkMagicRef(&chr_attacker, &chr_defender)
\brief
*/
native magic_chkMagicRef(&chr_attacker, &chr_defender);

/*!
\funcname magic_chkMana
\author Xanathar
\syntax magic_chkMana(const chr_caster, const spell_number)
\brief
*/
native magic_chkMana(const chr_caster, const spell_number);

/*!
\funcname magic_castExplosion
\author Xanathar
\syntax magic_castExplosion(const chr_att, const chr_def, const use_mana=1)
\brief
*/
native magic_castExplosion(const chr_att, const chr_def, const use_mana=1);

/*!
\funcname magic_castClumsy
\author Xanathar
\syntax magic_castClumsy(const chr_att, const chr_def, const use_mana=1)
\brief
*/
native magic_castClumsy(const chr_att, const chr_def, const use_mana=1);

/*!
\funcname magic_castCurse
\author Xanathar
\syntax magic_castCurse(const chr_att, const chr_def, const use_mana=1)
\brief
*/
native magic_castCurse(const chr_att, const chr_def, const use_mana=1);

/*!
\funcname magic_castFeeblem
\author Xanathar
\syntax magic_castFeeblem(const chr_att, const chr_def, const use_mana=1)
\brief
*/
native magic_castFeeblem(const chr_att, const chr_def, const use_mana=1);

/*!
\funcname magic_castFireball
\author Xanathar
\syntax magic_castFireball(const chr_att, const chr_def, const use_mana=1)
\brief
*/
native magic_castFireball(const chr_att, const chr_def, const use_mana=1);

/*!
\funcname magic_castFlameStr
\author Xanathar
\syntax magic_castFlameStr(const chr_att, const chr_def, const ignored=1)
\brief
*/
native magic_castFlameStr(const chr_att, const chr_def, const ignored=1);

/*!
\funcname magic_castHarm
\author Xanathar
\syntax magic_castHarm(const chr_att, const chr_def, const use_mana=1)
\brief
*/
native magic_castHarm(const chr_att, const chr_def, const use_mana=1);

/*!
\funcname magic_castMagicArr
\author Xanathar
\syntax magic_castMagicArr(const chr_att, const chr_def, const use_mana=1)
\brief
*/
native magic_castMagicArr(const chr_att, const chr_def, const use_mana=1);

/*!
\funcname magic_castLightning
\author Xanathar
\syntax magic_castLightning(const chr_att, const chr_def, const ignored=1)
\brief
*/
native magic_castLightning(const chr_att, const chr_def, const ignored=1);

/*!
\funcname magic_castMindBlast
\author Xanathar
\syntax magic_castMindBlast(const chr_att, const chr_def, const use_mana=1)
\brief
*/
native magic_castMindBlast(const chr_att, const chr_def, const use_mana=1);

/*!
\funcname magic_castParalyze
\author Xanathar
\syntax magic_castParalyze(const chr_att, const chr_def, const use_mana=1)
\brief
*/
native magic_castParalyze(const chr_att, const chr_def, const use_mana=1);

/*!
\funcname magic_castWeaken
\author Xanathar
\syntax magic_castWeaken(const chr_att, const chr_def, const use_mana=1)
\brief
*/
native magic_castWeaken(const chr_att, const chr_def, const use_mana=1);

/** @} */ // end of script_API_menu


/*************************************************************************
 PACKET-SEND RELATED PROTOTYPES
 *************************************************************************/

/*!
\funcname send_send
\author Xanathar
\syntax send_send(const socket, const lenght, const data[])
\brief
*/
native send_send(const socket, const lenght, const data[]);

/*!
\funcname send_confirmAttack
\author Xanathar
\syntax send_confirmAttack(const socket, const chr)
\brief
*/
native send_confirmAttack(const socket, const chr);

/*!
\funcname send_movingfx
\author Xanathar
\syntax send_movingfx(const chrsrc, const chrdest, const id, const speed = 5, const loop = 0, const explode = 1)
\brief
*/
native send_movingfx(const chrsrc, const chrdest, const id, const speed = 5, const loop = 0, const explode = 1);

/*!
\funcname send_boltfx
\author Xanathar
\syntax send_boltfx(const chr)
\brief
*/
native send_boltfx(const chr);

/*!
\funcname send_statUpdate
\author Xanathar
\syntax send_statUpdate(const chr)
\brief
*/
native send_statUpdate (const chr);

/*!
\funcname send_staticfx
\author Luxor
\syntax send_staticfx(const chr, const effect)
\brief
*/
native send_staticfx(const chr, const effect);

/*!
\brief test if status request from client is for character skills
\author Sparhawk
\since 0.82
\syntax rcve_skillsRequest( const socket )
\return true or false
*/
native rcve_skillsRequest( const socket );

/*!
\brief test if status request from client is for character stats
\author Sparhawk
\since 0.82
\return true or false
*/
native rcve_statsRequest (const socket);

/*************************************************************************
 TEMP-FX RELATED PROTOTYPES
 *************************************************************************/

/** \defgroup script_API_tempfx Temp-fx
 *  \ingroup script_API
 *  @{
 */

/*!
\funcname tempfx_activate
\author Xanathar
\syntax tempfx_activate(const type = 121, const chrsrc, const chrdest, const more, const dur = -1, const callback = -3)
\brief
*/
native tempfx_activate(const type = 121, const chrsrc, const chrdest, const more, const dur = -1, const callback = -3);

/** @} */ // end of script_API_tempfx

/*************************************************************************
 REGION RELATED PROTOTYPES
 *************************************************************************/

/** \defgroup script_API_reg Region
 *  \ingroup script_API
 *  @{
 */
 
/*!
\funcname rgn_setWeather
\author Xanathar
\syntax rgn_setWeather(const region, const weathertype = 0)
\brief
*/
native rgn_setWeather(const region, const weathertype = 0);

/*!
\funcname rgn_getWeather
\author Xanathar
\syntax rgn_getWeather(const region)
\brief
*/
native rgn_getWeather(const region);

/*!
\funcname rgn_isGuarded
\author Xanathar
\syntax rgn_isGuarded(const region)
\brief
*/
native rgn_isGuarded(const region);

/*!
\funcname rgn_canMark
\author Xanathar
\syntax rgn_canMark(const region)
\brief
*/
native rgn_canMark(const region);

/*!
\funcname rgn_canGate
\author Xanathar
\syntax rgn_canGate(const region)
\brief
*/
native rgn_canGate(const region);

/*!
\funcname rgn_canRecall
\author Xanathar
\syntax rgn_canRecall(const region)
\brief
*/
native rgn_canRecall(const region);

/*!
\funcname rgn_noMagicDamage
\author Xanathar
\syntax rgn_noMagicDamage(const region)
\brief
*/
native rgn_noMagicDamage(const region);

/*!
\funcname rgn_setGuarded
\author Sparhawk
\syntax rgn_setGuarded(const region, const trueOrFalse = 1)
\brief
*/
native rgn_setGuarded(const region, const trueOrFalse = 1);

/*!
\funcname rgn_setMark
\author Sparhawk
\syntax rgn_setMark(const region, const trueOrFalse = 1)
\brief
*/
native rgn_setMark(const region, const trueOrFalse = 1);

/*!
\funcname rgn_setGate
\author Sparhawk
\syntax rgn_setGate(const region, const trueOrFalse = 1)
\brief
*/
native rgn_setGate(const region, const trueOrFalse = 1);

/*!
\funcname rgn_setRecall
\author Sparhawk
\syntax rgn_setRecall(const region, const trueOrFalse = 1)
\brief
*/
native rgn_setRecall(const region, const trueOrFalse = 1);

/*!
\funcname rgn_setMagicDamage
\author Sparhawk
\syntax rgn_setMagicDamage(const region, const trueOrFalse = 1)
\brief
*/
native rgn_setMagicDamage(const region, const trueOrFalse = 1);

/*!
\funcname rgn_isValid
\author Sparhawk
\syntax rgn_isValid(const region)
\brief
*/
native rgn_isValid(const region);

/*!
\funcname rgn_getName
\author Sparhawk
\syntax rgn_getName(const region, regionName[])
\brief
*/
native rgn_getName(const region, regionName[]);

/** @} */ // end of script_API_reg


/*************************************************************************
 SET RELATED PROTOTYPES
 *************************************************************************/

/** \defgroup script_API_set Set
 *  \ingroup script_API
 *  @{
 */

/*!
\funcname set_open
\author Xanathar
\syntax set_open()
\brief
*/
native set_open();

/*!
\funcname set_close
\author Xanathar
\syntax set_close(const set)
\brief
*/
native set_close(const set);

/*!
\funcname set_pop
\author Xanathar
\syntax set_pop(const set)
\brief
*/
native set_pop(const set);

/*!
\funcname set_push
\author Xanathar
\syntax set_push(const set, const value)
\brief
*/
native set_push(const set, const value);

/*!
\funcname set_fillOwnedChars
\author Xanathar
\syntax set_fillOwnedChars(const set, const chrowner, const includestabled = 1, const includeonlyfollowing = 0)
\brief
*/
native set_fillOwnedChars(const set, const chrowner, const includestabled = 1, const includeonlyfollowing = 0);

/*!
\funcname set_fillChrNearXY
\author Xanathar
\syntax set_fillChrNearXY(const set, const x, const y, const distance = 10, const excludeofflineplayers = 1)
\brief
*/
native set_fillChrNearXY(const set, const x, const y, const distance = 10, const excludeofflineplayers = 1);

/*!
\funcname set_fillItemsInCont
\author Xanathar
\syntax set_fillItemsInCont(const set, const serial, const includeSubCont = 1)
\brief
*/
native set_fillItemsInCont(const set, const serial, const includeSubCont = 1);

/*!
\funcname set_size
\author Xanathar
\syntax set_size(const set)
\brief
*/
native set_size(const set);

/*!
\funcname set_fillItemsAtXY
\author Xanathar
\syntax set_fillItemsAtXY(const set, const x, const y, const type = -1, const id = -1)
\brief
*/
native set_fillItemsAtXY(const set, const x, const y, const type = -1, const id = -1 );

/*!
\funcname set_fillItemsNearXY
\author Luxor
\syntax set_fillItemsNearXY(const set, const x, const y, const distance = 10, const bExcludeNotMovableItems = 1)
\brief
*/
native set_fillItemsNearXY(const set, const x, const y, const distance = 10, const bExcludeNotMovableItems = 1 );

/** @} */ // end of script_API_set


/*************************************************************************
 MAP RELATED PROTOTYPES
 *************************************************************************/

/** \defgroup script_API_map Map
 *  \ingroup script_API
 *  @{
 */


/*!
\funcname map_canMoveHere
\author Sparhawk
\syntax map_canMoveHere(const x, const y, const z)
\brief
*/
native map_canMoveHere( const x, const y, const z );

/*!
\funcname map_distance
\author Sparhawk
\syntax map_distance(const x1, const y1, const z1, const x2, const y2, const z2)
\brief
*/
native map_distance( const x1, const y1, const z1, const x2, const y2, const z2 );

/*!
\funcname map_getTileName
\author Luxor
\syntax map_getTileName(const x, const y, const name[])
\brief
*/
native map_getTileName(const x, const y, const name[]);

/*!
\funcname map_getTileID
\author Keldan
\syntax map_getTileID(const x, const y, const z)
\brief returns ID of the tile at coords.
*/
native map_getTileID(const x, const y, const z);

/*!
\funcname map_getFloorTileID 
\author Keldan
\syntax map_getFloorTileID(const x, const y)
\brief returns ID of the ground tile at coords.
*/
native map_getFloorTileID(const x, const y);

/*! 
\funcname map_isUnderStatic
\syntax map_isUnderStatic (const x, const y, const z)
\brief return true if position is located under a static item 
\author Keldan 
\since 0.82 
\param 1: x first location 
\param 2: y first location 
\param 2: z first location 
\return INVALID or true if under a "roof" (any static item in fact) or false 
*/
native map_isUnderStatic (const x, const y, const z);

/** @} */ // end of script_API_map


/*************************************************************************
 GUILD RELATED PROTOTYPES
 *************************************************************************/

/** \defgroup script_API_guild Guild
 *  \ingroup script_API
 *  \attention not used now
 *  @{
 */

/*!
\funcname guild_setProperty
\author Endymion
\syntax guild_setProperty(const guild, const property, const subprop=0, ...)
\brief
*/
native guild_setProperty( const guild, const property, const subprop=0, ...);

/*!
\funcname guild_getProperty
\author Endymion
\syntax guild_getProperty(const guild, const property, const subprop=0, ...)
\brief
*/
native guild_getProperty( const guild, const property, const subprop=0, ...);

/*!
\funcname guild_placeStone
\author Endymion
\syntax guild_placeStone(const chr, const itm)
\brief
*/
native guild_placeStone( const chr, const itm );

/*!
\funcname guild_addMember
\author Endymion
\syntax guild_addMember(const guild, const chr)
\brief
*/
native guild_addMember( const guild, const chr );

/*!
\brief return the number of members in a guild
\author Sparhawk
\since 0.82
\param 1: the guild
\return number of members or invalid when guild does not exist
*/
native guild_countMember( const guild );

/*!
\brief Add a recuit to a guild
\author Endymion
\since 0.82
\param 1: the guild
\param 2: the new recruit
\return true or false
*/
native guild_addRecruit( const guild, const chr );

/*!
\brief Given recruit are refuse
\author Endymion
\since 0.82
\param 1: the guild
\param 2: the recruit
\return true or false
*/
native guild_refuseRecruit( const guild, const chr )

/*!
\brief return the number of recruits in a guild
\author Sparhawk
\since 0.82
\param 1: the guild
\return number of recruits or invalid
*/
native guild_countRecruit( const guild );

/*!
\funcname guild_getMbrByIdx
\author Endymion
\syntax guild_getMbrByIdx(const guild, const idx)
\brief
*/
native guild_getMbrByIdx( const guild, const idx );

/*!
\funcname guild_getMaster
\author Sparhawk
\syntax guild_getMaster(const guild)
\param guild: the guild from which you want to get the master
\return serial of guildmaster or invalid
\brief Return the guildmaster for a given guild
*/
native guild_getMaster( const guild );

/*!
\brief check if guild exists
\author Sparhawk
\since 0.82
\param 1: the guild
\return true or false
*/
native guild_exists( const guild );

/*!
\brief Get the recruit by given index
\author Endymion
\since 0.82
\param 1: the guild
\param 2: the recruit index
\return the recruit or INVALID
*/
native guild_getRecByIdx( const guild, const idx );


/*!
\brief Set the guild the char is a member of
\author Sparhawk
\since 0.82.rc3
\param 1 character serial
\param 2 guild serial
\note	Not implemented yet...
\return 1
*/
native chr_setGuild();

/*!
\brief A member resign from his guild
\author Endymion
\since 0.82
\param 1: the guild
\param 2: the member
\TODO Handle situation if member is guildmaster & if guild is empty after resign
*/
native guild_resignMember (const guild, const chr);

/** @} */ // end of script_API_guild


/**
 * \defgroup script_constants Constants
 * \ingroup script
 * All constants, used in API function
 */

/*************************************************************************
 VERSION CONTROL CONSTANTS
 *************************************************************************/

/** \defgroup script_const_version Version
 *  \ingroup script_constants
 *  @{
 */

const VERTYPE_SUPPORTED = 0x1;
const VERTYPE_PRIVATE = 0x2;
const VERTYPE_BETA = 0x4;
const VERTYPE_SPECIAL = 0x8;
const VERTYPE_EZ = 0x80;

const PLATFORM_UNKNOWN = 0;
const PLATFORM_WINCONSOLE = 1;
const PLATFORM_WINGUI = 2;
const PLATFORM_WINGUIEZ = 130;      //0x80 || WINGUI
const PLATFORM_WINSERVICE = 3;
const PLATFORM_LINUX = 4;
const PLATFORM_BEOS = 5;

/** @} */ // end of script_const_version

/*************************************************************************
 SKILL RELATED CONSTANTS
 *************************************************************************/

/** \defgroup script_const_skill Skill
 *  \ingroup script_constants
 *  @{
 */

const SK_ALCHEMY = 0;
const SK_ANATOMY = 1;
const SK_ANIMALLORE = 2;
const SK_ITEMID = 3;
const SK_ARMSLORE = 4;
const SK_PARRYING = 5;
const SK_BEGGING = 6;
const SK_BLACKSMITHING = 7;
const SK_BOWCRAFT = 8;
const SK_PEACEMAKING = 9;
const SK_CAMPING = 10;
const SK_CARPENTRY = 11;
const SK_CARTOGRAPHY = 12;
const SK_COOKING = 13;
const SK_DETECTINGHIDDEN = 14;
const SK_ENTICEMENT = 15;
const SK_EVALUATINGINTEL = 16;
const SK_HEALING = 17;
const SK_FISHING = 18;
const SK_FORENSICS = 19;
const SK_HERDING = 20;
const SK_HIDING = 21;
const SK_PROVOCATION = 22;
const SK_INSCRIPTION = 23;
const SK_LOCKPICKING = 24;
const SK_MAGERY = 25;
const SK_MAGICRESISTANCE = 26;
const SK_TACTICS = 27;
const SK_SNOOPING = 28;
const SK_MUSICIANSHIP = 29;
const SK_POISONING = 30;
const SK_ARCHERY = 31;
const SK_SPIRITSPEAK = 32;
const SK_STEALING = 33;
const SK_TAILORING = 34;
const SK_TAMING = 35;
const SK_TASTEID = 36;
const SK_TINKERING = 37;
const SK_TRACKING = 38;
const SK_VETERINARY = 39;
const SK_SWORDSMANSHIP = 40;
const SK_MACEFIGHTING = 41;
const SK_FENCING = 42;
const SK_WRESTLING = 43;
const SK_LUMBERJACKING = 44;
const SK_MINING = 45;
const SK_MEDITATION = 46;
const SK_STEALTH = 47;
const SK_REMOVETRAPS = 48;

/** @} */ // end of script_const_skill

/*************************************************************************
 CHARACHTER RELATED CONSTANTS
 *************************************************************************/

/**
 * \defgroup script_const_obj Object
 * \ingroup script_constants
 * Object constants
 */


/** \defgroup script_const_chr_pos Position
 *  \ingroup script_const_chr
 *  @{
 */

//second cp for positions
const CP2_X = 0;
const CP2_Y = 1;
const CP2_Z = 2;
const CP2_DZ = 3;
const CP2_DISPZ = 3;

/** @} */ // end of script_const_chr_pos


/** \defgroup script_const_chr_stats Stats
 *  \ingroup script_const_chr
 *  @{
 */

//second cp for generic stat
const CP2_EFF   = 0;
const CP2_DEC  = 1;
const CP2_REAL = 2;
const CP2_ACT  = 3;

//second cp for strenght (more readable :))
const CP2_STR   = 0;
const CP2_STRDEC  = 1;
const CP2_STRREAL = 2;
const CP2_HITPOINTS  = 3;
const CP2_HP  = 3;

//second cp for dexterity (more readable :))
const CP2_DEX  = 0;
const CP2_DEXDEC  = 1;
const CP2_DEXREAL = 2;
const CP2_STAMINA  = 3;

//second cp for intelligence (more readable :))
const CP2_INT   = 0;
const CP2_INTDEC  = 1;
const CP2_INTREAL = 2;
const CP2_MANA  = 3;

/** @} */ // end of script_const_chr_stats

/** \defgroup script_const_chr Character
 *  \ingroup script_const_obj
 *  @{
 */


//property list
const CP_CANTRAIN = 0;
const CP_DEAD = 1;
const CP_FREE = 2;
const CP_GUARDED = 3;
const CP_GUILDTRAITOR = 4;
const CP_INCOGNITO = 6;
const CP_ONHORSE = 7;
const CP_POLYMORPH = 8;
const CP_TAMED = 9;
const CP_UNICODE = 10;
const CP_SHOPKEEPER = 11;
const CP_ATTACKFIRST = 12;
const CP_ISBEINGTRAINING = 13;
const CP_GUILDTOGGLE = 14;
const CP_OVERWEIGHTED = 15;

const CP_BLOCKED = 101;
const CP_CELL = 102;
const CP_COMMANDLEVEL = 103;
const CP_DIR = 104;
const CP_DIR2 = 105;
const CP_FIXEDLIGHT = 106;
const CP_FLAG = 107;
const CP_FLY_STEPS = 108;
const CP_GMRESTRICT = 109;
const CP_HIDDEN = 110;
const CP_ID = 111;
const CP_LOCKSKILL = 112;
const CP_MULTISERIAL2 = 113;
const CP_NPC = 114;
const CP_NPCTYPE = 115;
const CP_NPCWANDER = 116;
const CP_OLDNPCWANDER = 117;
const CP_ORGSKIN = 118;
const CP_OWNSERIAL2 = 119;
const CP_PRIV2 = 121;
const CP_REACTIVEARMORED = 122;
const CP_REGION = 123;
const CP_SERIAL2 = 124;
const CP_SHOP = 125; //Sparhawk DEPRECIATED use CP_SHOPKEEPER
const CP_SKIN = 126;
const CP_SPEECH = 127;
const CP_WAR = 128;
const CP_XID = 129;
const CP_XSKIN = 130;
const CP_NXWFLAGS = 131;
const CP_RESISTS = 132;
const CP_TRAININGPLAYERIN = 133;
const CP_PRIV = 134;
const CP_DAMAGETYPE = 135;

const CP_ACCOUNT = 200;
const CP_ADVOBJ = 201;
const CP_ATT = 202;
const CP_ATTACKER = 203;
const CP_BEARDCOLOR = 204;
const CP_BEARDSERIAL = 205;
const CP_BEARDSTYLE = 206;
const CP_CALLNUM = 207;
const CP_CARVE = 208;
const CP_CASTING = 209;
const CP_CLIENTIDLETIME = 210;
const CP_COMBATHITMESSAGE = 211;
const CP_CREATIONDAY = 212;
const CP_CRIMINALFLAG = 213;
const CP_DEATHS = 214;
const CP_DEF = 215;
const CP_DEXTERITY = 216;
const CP_DISABLED = 217;
const CP_FAME = 218;
const CP_FLEEAT = 219;
const CP_FOODPOSITION = 220;
const CP_FPOS1_NPCWANDER = 221;
const CP_FPOS2_NPCWANDER = 222;
const CP_FTARG = 223;
const CP_GMMOVEEFF = 224;
const CP_GUILDFEALTY = 225;
const CP_GUILDNUMBER = 226;
const CP_HAIRCOLOR = 228;
const CP_HAIRSERIAL = 229;
const CP_HAIRSTYLE = 230;
const CP_HIDAMAGE = 231;
const CP_HOLDGOLD = 232;
const CP_HOMELOCPOS = 233;
const CP_HUNGER = 234;
const CP_HUNGERTIME = 235;
const CP_INTELLIGENCE = 236;
const CP_KARMA = 237;
const CP_KEYNUMBER = 238;
const CP_KILLS = 239;
const CP_LODAMAGE = 240;
const CP_LOGOUT = 241;
const CP_MAKING = 242;
const CP_MEDITATING = 243;
const CP_MENUPRIV = 244;
const CP_MULTISERIAL = 245;
const CP_MURDERERSER = 246;
const CP_MURDERRATE = 247;
const CP_MUTETIME = 248;
const CP_NAMEDEED = 249;
const CP_NEXTACT = 250;
const CP_NPCAI = 251;
const CP_NPCMOVETIME = 252;
const CP_OBJECTDELAY = 253;
const CP_OLDPOS = 254;
const CP_OWNSERIAL = 255;
const CP_PACKITEM = 256;
const CP_POISON = 257;
const CP_POISONED = 258;
const CP_POISONTIME = 259;
const CP_POISONTXT = 260;
const CP_POISONWEAROFFTIME = 261;
const CP_POSITION = 262;
const CP_POSTTYPE = 263;
const CP_PREVPOS = 264;
const CP_PRIV3 = 265;
const CP_QUESTBOUNTYPOSTSERIAL = 266;
const CP_QUESTBOUNTYREWARD = 267;
const CP_QUESTDESTREGION = 268;
const CP_QUESTORIGREGION = 269;
const CP_REATTACKAT = 270;
const CP_REGEN = 271;
const CP_REGEN2 = 272;
const CP_REGEN3 = 273;
const CP_ROBE = 274;
const CP_RUNNING = 275;
const CP_SERIAL = 276;
const CP_SKILLDELAY = 277;
const CP_SMELTITEM = 278;
const CP_SMOKEDISPLAYTIME = 279;
const CP_SMOKE = 280;
const CP_SPADELAY = 281;
const CP_SPATIMER = 282;
const CP_SPATTACK = 283;
const CP_SPAWNREGION = 284;
const CP_SPAWNSERIAL = 285;
const CP_SPELL = 286;
const CP_SPELLACTION = 287;
const CP_SPELLTIME = 288;
const CP_SPLIT = 290;
const CP_SPLITCHNC = 291;
const CP_SQUELCHED = 292;
const CP_STABLEMASTER_SERIAL = 293;
const CP_STEALTH = 294;
const CP_STRENGHT = 295;
const CP_SUMMONTIMER = 296;
const CP_SWINGTARG = 297;
const CP_TAILITEM = 298;
const CP_TAMING = 299;
const CP_TARG = 300;
const CP_TARGTRIG = 301;
const CP_TEMPFLAGTIME = 302;
const CP_TIME_UNUSED = 303;
const CP_TIMEOUT = 304;
const CP_TIMEUSED_LAST = 305;
const CP_TRACKINGDISPLAYTIMER = 306;
const CP_TRACKINGTARGET = 307;
const CP_TRACKINGTIMER = 308;
const CP_TRAINER = 309;
const CP_TRIGGER = 311;
const CP_WEIGHT = 312;
const CP_WORKLOCPOS = 313;
const CP_AMXFLAGS = 314;
const CP_NPCRACE = 315;
const CP_LASTMOVETIME = 319;

const CP_BASESKILL = 400;
const CP_SKILL = 401;
const CP_GUILDTYPE = 402;

const CP_STR_DISABLEDMSG = 450;
const CP_STR_GUILDTITLE = 451;
const CP_STR_NAME = 453;
const CP_STR_ORGNAME = 454;
const CP_STR_TITLE = 455;
const CP_STR_TRIGWORD = 456;
const CP_STR_SPEECHWORD = 457;	// word/phrase in speech that triggered speech override
const CP_STR_SPEECH = 458; // entire speech that contains word/phrase that triggered speech override

/** @} */ // end of script_const_chr


/*************************************************************************
 ITEM RELATED CONSTANTS
 *************************************************************************/

/** \defgroup script_const_item_pos Position
 *  \ingroup script_const_item
 *  @{
 */

//second cp for positions
const IP2_X = 0;
const IP2_Y = 1;
const IP2_Z = 2;
const IP2_DZ = 3;
const IP2_DISPZ = 3;

/** @} */ // end of script_const_item

/** \defgroup script_const_item Item
 *  \ingroup script_const_obj
 *  @{
 */

const IP_INCOGNITO = 0;
const IP_COLOR = 100;
const IP_CONTAINERSERIAL2 = 101;
const IP_CORPSE = 102;
const IP_DOORDIR = 103;
const IP_DOOROPEN = 104;
const IP_DYE = 105;
const IP_FREE = 106;
const IP_GLOWFX = 107;
const IP_GLOWOLDCOLOR = 108;
const IP_ID = 109;
const IP_LAYER = 110;
const IP_MAGIC = 111;
const IP_MORE = 112;
const IP_MOREB = 113;
const IP_OFFSPELL = 114;
const IP_OLDLAYER = 115;
const IP_OWNERSERIAL2 = 116;
const IP_PILEABLE = 117;
const IP_PRIV = 118;
const IP_SERIAL2 = 119;
const IP_VISIBLE = 120;
const IP_DAMAGETYPE = 121;
const IP_AUXDAMAGETYPE = 122;
const IP_ATT = 200;
const IP_CARVE = 201;
const IP_CONTAINERSERIAL = 202;
const IP_DECAYTIME = 203;
const IP_DEF = 204;
const IP_DEXBONUS = 205;
const IP_DEXREQUIRED = 206;
const IP_DISABLED = 207;
const IP_GATENUMBER = 208;
const IP_GATETIME = 209;
const IP_GLOW = 210;
const IP_GOOD = 211;
const IP_HIDAMAGE = 212;
const IP_HP = 213;
const IP_INTBONUS = 214;
const IP_INTREQUIRED = 215;
const IP_ITEMHAND = 216;
const IP_LODAMAGE = 217;
const IP_MADEWITH = 218;
const IP_MAXHP = 219;
const IP_MOREPOSITION = 220;
const IP_MULTISERIAL = 221;
const IP_MURDERTIME = 222;
const IP_OLDCONTAINERSERIAL = 223;
const IP_OLDPOSITION = 224;
const IP_OWNERSERIAL = 225;
const IP_POISONED = 226;
const IP_POSITION = 227;
const IP_RANK = 228;
const IP_REQSKILL = 229;
const IP_RESTOCK = 230;
const IP_RNDVALUERATE = 231;
const IP_SECUREIT = 232;
const IP_SERIAL = 233;
const IP_SMELT = 234;
const IP_SPAWNREGION = 235;
const IP_SPAWNSERIAL = 236;
const IP_SPEED = 237;
const IP_STRBONUS = 238;
const IP_STRREQUIRED = 239;
const IP_TIME_UNUSED = 240;
const IP_TIME_UNUSEDLAST = 241;
const IP_TRIGGER = 242;
const IP_TRIGGERUSES = 243;
const IP_TRIGTYPE = 244;
const IP_TYPE = 245;
const IP_TYPE2 = 246;
const IP_VALUE = 247;
const IP_WEIGHT = 248;
const IP_WIPE = 249;
const IP_AMXFLAGS = 250;
const IP_SCRIPTID = 251;
const IP_ANIMID = 252;
const IP_RESISTS = 253;
const IP_AUXDAMAGE = 254;
const IP_AMMO = 255;
const IP_AMMOFX = 256;
const IP_AMOUNT = 400;
const IP_AMOUNT2 = 401;
const IP_DIR = 402;
const IP_STR_CREATOR = 450;
const IP_STR_DESCRIPTION = 451;
const IP_STR_DISABLEDMSG = 452;
const IP_STR_MURDERER = 453;
const IP_STR_NAME = 454;
const IP_STR_NAME2 = 455;

/** @} */ // end of script_const_item


/*************************************************************************
 TRIGGER AND EVENTS RELATED CONSTANTS
 *************************************************************************/

const TRIG_ABORT = 1;
const TRIG_CONTINUE = 0;

const ITEM_DONTUSE = 0;
const ITEM_CANUSE = 1;

const ITEM_USE_UNKNOWN = 0;
const ITEM_USE_WEAR = 1;
const ITEM_USE_CHECKEQUIP = 2;
const ITEM_USE_DBLCLICK = 3;

const SKILLADV_DONTRAISE = 0;
const SKILLADV_RAISE = 1;

const DISPELTYPE_UNKNOWN = 0;
const DISPELTYPE_DISPEL = 1;
const DISPELTYPE_TIMEOUT = 2;
const DISPELTYPE_GMREMOVE = 3;

const STATCAP_CAP = 0;
const STATCAP_STR = 1;
const STATCAP_DEX = 2;
const STATCAP_INT = 3;

const REPUTATION_KARMA = 1;
const REPUTATION_FAME = 2;

const DECAYTYPE_UNKNOWN = 0;
const DECAYTYPE_DECAY = 1;
const DECAYTYPE_GMREMOVE = 2;

const POISON_NONE = 0;
const POISON_LESSER = 1;
const POISON_STANDARD = 2;
const POISON_GREATER = 3;
const POISON_DEADLY = 4;

const BANKBOX_BANK = 0;
const BANKBOX_WARE = 1;
const BANKBOX_SPECIAL = 1;

/*************************************************************************
 MENU RELATED CONSTANTS
 *************************************************************************/

/** \defgroup script_const_menu Menu
 *  \ingroup script_constants
 *  @{
 */

const MENUSTYLE_STONE = 0;
const MENUSTYLE_SCROLL = 1;
const MENUSTYLE_PAPER = 2;
const MENUSTYLE_BLACKBOARD = 3;
const MENUSTYLE_TRASPARENCY = 4;

/** @} */ // end of script_const_menu


/*************************************************************************
 EVENT HANDLERS RELATED CONSTANTS
 *************************************************************************/

/** \defgroup script_const_event Event Handler
 *  \ingroup script_const_obj
 *  @{
 */

const EVENTTYPE_STATIC = 0;
const EVENTTYPE_DYNAMIC = 1;

/** @} */ // end of script_const_event

/** \defgroup script_const_item_event Event Handler
 *  \ingroup script_const_item
 *  @{
 */

enum
{
	EVENT_ITM_ONSTART = 0,
        EVENT_ITM_ONDAMAGE,
        EVENT_ITM_ONEQUIP,
        EVENT_ITM_ONUNEQUIP,
        EVENT_ITM_ONCLICK,
        EVENT_ITM_ONDBLCLICK,
        EVENT_ITM_ONPUTINBACKPACK,
        EVENT_ITM_ONDROPINLAND,
        EVENT_ITM_ONCHECKCANUSE,
        EVENT_ITM_ONTRANSFER,
        EVENT_ITM_ONSTOLEN,
        EVENT_ITM_ONPOISONED,
        EVENT_ITM_ONDECAY,
        EVENT_ITM_ONREMOVETRAP,
        EVENT_ITM_ONLOCKPICK,
        EVENT_ITM_ONWALKOVER,
        EVENT_ITM_ONPUTITEM,
        EVENT_ITM_ONTAKEFROMCONTAINER,
        ALLITEMEVENTS
};

/** @} */ // end of script_const_item_event

/** \defgroup script_const_chr_event Event Handler
 *  \ingroup script_const_chr
 *  @{
 */

enum
{
	EVENT_CHR_ONDEATH = 0,
	EVENT_CHR_ONWOUNDED,
	EVENT_CHR_ONHIT,
	EVENT_CHR_ONHITMISS,
	EVENT_CHR_ONGETHIT,
	EVENT_CHR_ONREPUTATIONCHG,
	EVENT_CHR_ONDISPEL,
	EVENT_CHR_ONRESURRECT,
	EVENT_CHR_ONFLAGCHG,
	EVENT_CHR_ONWALK,
	EVENT_CHR_ONADVANCESKILL,
	EVENT_CHR_ONADVANCESTAT,
	EVENT_CHR_ONBEGINATTACK,
	EVENT_CHR_ONBEGINDEFENSE,
	EVENT_CHR_ONTRANSFER,
	EVENT_CHR_ONMULTIENTER,
	EVENT_CHR_ONMULTILEAVE,
	EVENT_CHR_ONSNOOPED,
	EVENT_CHR_ONSTOLEN,
	EVENT_CHR_ONPOISONED,
	EVENT_CHR_ONREGIONCHANGE,
	EVENT_CHR_ONCASTSPELL,
	EVENT_CHR_ONGETSKILLCAP,
	EVENT_CHR_ONGETSTATCAP,
	EVENT_CHR_ONBLOCK,
	EVENT_CHR_ONSTART,
	EVENT_CHR_ONHEARTBEAT,
	EVENT_CHR_ONBREAKMEDITATION,
	EVENT_CHR_ONCLICK,
	EVENT_CHR_ONMOUNT,
	EVENT_CHR_ONDISMOUNT,
	EVENT_CHR_ONKILL,
	EVENT_CHR_ONHITSTART,
	EVENT_CHR_MAX
}

/** @} */ // end of script_const_chr_event

/*************************************************************************
 TEMP-FX RELATED CONSTANTS
 *************************************************************************/

/** \defgroup script_const_tempfx Temp-Fx
 *  \ingroup script_constants
 *  @{
 */

const TFX_SPELL_PARALYZE =  1;
const TFX_SPELL_LIGHT = 2;
const TFX_SPELL_CLUMSY = 3;
const TFX_SPELL_FEEBLEMIND = 4;
const TFX_SPELL_WEAKEN = 5;
const TFX_SPELL_AGILITY = 6;
const TFX_SPELL_CUNNING = 7;
const TFX_SPELL_STRENGHT = 8;
const TFX_ALCHEMY_GRIND = 9;
const TFX_ALCHEMY_END = 10;
const TFX_SPELL_BLESS = 11;
const TFX_SPELL_CURSE = 12;
const TFX_AUTODOOR = 13;
const TFX_TRAINDUMMY = 14;
const TFX_SPELL_REACTARMOR = 15;
const TFX_EXPLOTIONMSG = 16;
const TFX_EXPLOTIONEXP = 17;
const TFX_SPELL_POLYMORPH = 18;
const TFX_SPELL_INCOGNITO = 19;
const TFX_LSD = 20;
const TFX_SPELL_PROTECTION = 21;
const TFX_HEALING_HEAL = 22;
const TFX_HEALING_RESURRECT = 23;
const TFX_HEALING_CURE = 24;
const TFX_POTION_DELAY = 25;
const TFX_GM_HIDING = 33;
const TFX_GM_UNHIDING = 34;
const TFX_HEALING_DELAYHEAL = 35;
const TFX_COMBAT_PARALYZE = 44;
const TFX_COMBAT_CONCUSSION = 45;
const TFX_AMXCUSTOM = 121;
const TFX_GREY = 122;

const TFXM_START = 0;
const TFXM_END = 1;
const TFXM_ON = 2;
const TFXM_OFF = 3;
const TFXM_REVERSE = 4;

/** @} */ // end of script_const_tempfx


/*************************************************************************
NPCTALK NPCEMOTE RELATED CONSTANTS
*************************************************************************/

/** \defgroup script_const_chr_talk Talk
 *  \ingroup script_const_chr
 *  @{
 */

const NPC_TALK = 1;
const NPC_TALK_ALL = 2;
const NPC_TALK_RUNIC = 3;
const NPC_TALK_ALL_RUNIC = 4;
const NPC_EMOTE = 5;
const NPC_EMOTE_ALL = 6;

/** @} */ // end of script_const_chr_talk


/*************************************************************************
 NXW-FLAGS RELATED CONSTANTS
 *************************************************************************/

/** \defgroup script_const_nxwflag Nxw-Flag
 *  \ingroup script_constants
 *  @{
 */

const NXWF0_GREY = 1;
const NXWF0_PERMAGREY = 2;

/** @} */ // end of script_const_nxwflag

/*************************************************************************
 WEATHER RELATED CONSTANTS
 *************************************************************************/

/** \defgroup script_const_weather Wheater
 *  \ingroup script_constants
 *  @{
 */

const WEATHER_SUN = 0;
const WEATHER_RAIN = 1;
const WEATHER_SNOW = 2;

const SEASON_SPRING = 0;
const SEASON_SUMMER = 1;
const SEASON_AUTUMN = 2;
const SEASON_FALL   = 2;
const SEASON_WINTER = 3;
const SEASON_DEAD   = 4;

/** @} */ // end of script_const_weather


/*************************************************************************
 DIRECTION RELATED CONSTANTS
 *************************************************************************/

/** \defgroup script_const_direction Direction
 *  \ingroup script_constants
 *  @{
 */

const DIR_NORTH = 0;
const DIR_NORTHEAST = 1;
const DIR_EAST  = 2;
const DIR_SOUTHEAST = 3;
const DIR_SOUTH = 4;
const DIR_SOUTHWEST = 5;
const DIR_WEST  = 6;
const DIR_NORTHWEST = 7;

/** @} */ // end of script_const_direction


/*************************************************************************
 LINE OF SIGHT RELATED CONSTANTS
 *************************************************************************/

/** \defgroup script_const_los Line of Sight
 *  \ingroup script_const_obj
 *  @{
 */

const TREES_BUSHES = 1;
const WALLS_CHIMNEYS = 2;
const DOORS = 4;
const ROOFING_SLANTED = 8;
const FLOORS_FLAT_ROOFING = 16;
const LAVA_WATER = 32;

/** @} */ // end of script_const_los


/*************************************************************************
 DAMAGE TYPES CONSTANTS
 *************************************************************************/

/** \defgroup script_const_damage Damage Types
 *  \ingroup script_const_obj
 *  @{
 */

enum {
	DAMAGE_PURE = 0,
	DAMAGE_SLASH, 
	DAMAGE_PIERCE, 
	DAMAGE_BLUDGEON, 
	DAMAGE_BACKSTAB,
	DAMAGE_FIRE, 
	DAMAGE_ELECTRICITY, 
	DAMAGE_MENTAL, 
	DAMAGE_POISON, 
	DAMAGE_COLD,
	DAMAGE_FORCE, 
	DAMAGE_HOLY, 
	DAMAGE_MAGIC, 
	MAX_RESISTANCE_INDEX
};

/** @} */ // end of script_const_damage


/*************************************************************************
 AMX VAR SYSTEM VARIABLES
 *************************************************************************/

/** \defgroup script_const_amxvar Amx Variables
 *  \ingroup script_const_obj
 *  @{
 */

 const VAR_TYPE_ANY = 0;
 const VAR_TYPE_INTEGER = 1;
 const VAR_TYPE_STRING = 3;

 const VAR_ERROR_NONE = 0;
 const VAR_ERROR_UNKNOWN_VAR = 1;
 const VAR_ERROR_DUPLICATE_VAR = 2;
 const VAR_ERROR_WRONG_TYPE = 3;
 const VAR_ERROR_ACCESS_DENIED = 4;
 
/** @} */ // end of script_const_amxvar
 
 
/*************************************************************************
 GUILD VARIABLES
 *************************************************************************/

/** \defgroup script_const_guild Guild
 *  \ingroup script_constants
 *  @{
 */

const GP_TYPE = 100;
 const GP_GUILDMASTER = 200;
 const GP_MEMBERCOUNT = 201;
 const GP_RECRUITCOUNT = 202;
 const GP_NAME = 450;
 const GP_WEBPAGE = 451;
 const GP_CHARTER = 452;
 const GP_ABBREVIATION = 453;
 
/** @} */ // end of script_const_guild
 

/*************************************************************************
 TIMER CONSTANTS
 *************************************************************************/

/** \defgroup script_const_timer Timer
 *  \ingroup script_constants
 *  @{
 */

 const TIMER_PAUSE = 1;
 const TIMER_SAVE = 2;

/** @} */ // end of script_const_timer


