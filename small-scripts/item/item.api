// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// || NoX-Wizard	: Embedded Small Scripts			||
// || Maintained by	: Luxor, Sparhawk				||
// || Last Update	: 06-apr-2003					||
// || Designed for NXW 	: 0.82						||
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

#if defined _nxw_item_api_
  #endinput
#endif
#define _nxw_item_api_

#include "small-scripts/include/nxw_lib"

/*!
\brief Check if a serial is an item serial
\author Endymion
\fn isItem( const serial )
\param serial the serial
\return true if is an item serial, false else
\note INVALID return false
*/
public isItem( const serial ) { 
	return ( ( serial>=FIRST_ITEM_SERIAL ) && ( serial!=INVALID ) ); 
}

/*!
\author Xanathar
\fn getItemTarget()
\brief Gets the targetted item
*/
native getItemTarget();


/*!
\author Luxor
\fn getItemFromSerial(const serial)
\param serial: the serial
\brief Gets the item of the given serial
*/
native getItemFromSerial(const serial);

/*!
\author Xanathar
\fn getItemFromSerial(const chr)
\param chr: the character
\brief Gets the socket of the given char
*/
native getSocketFromChar(const chr);
/*!
\author Xanathar
\fn itm_getProperty(const item, const property, const subprop=0, ...)
\brief
*/
native itm_getProperty(const item, const property, const subprop=0, ...);

/*!
\author Xanathar
\fn itm_setProperty(const item, const property, const subprop=0, ...)
\brief
*/
native itm_setProperty(const item, const property, const subprop=0, ...);

/*!
\brief Add the item to container
\author Xanathar
\fn itm_contAddItem(const container, const item, const x=INVALID, const y=INVALID)
\param 1 the container
\param 2 the item
\param 3 x location or INVALID if rand pos
\param 4 y location or INVALID if rand pos
*/
native itm_contAddItem(const container, const item, const x=INVALID, const y=INVALID);

/*!
\author Xanathar
\fn itm_color(const item)
\brief
*/
native itm_color(const item);

/*!
\author Xanathar
\fn itm_contPileItem(const container, const item)
\brief
*/
native itm_contPileItem(const container, const item);

/*!
\author Xanathar
\fn itm_contCountItems(const container, const id, const color = -1)
\brief
*/
native itm_contCountItems(const container, const id, const color = -1);

/*!
\author Keldan
\fn itm_countItemsByID(const container, const ScriptID)
\brief return amount of items identified by ScriptID
*/
native itm_countItemsByID(const container, const ScriptID);

/*!
\author Xanathar
\fn itm_contDelAmount(const container, const amount, const id, const color = -1)
\brief
*/
native itm_contDelAmount(const container, const amount, const id, const color = -1);

/*!
\author Keldan
\fn itm_delAmountByID(const container, const amount, const ScriptID)
\brief remove from container "amount" number of items, identified by ScriptID
*/
native itm_delAmountByID(const container, const amount, const ScriptID);

/*!
\author Xanathar
\fn itm_moveTo(const item, const x, const y, const z)
\brief
*/
native itm_moveTo(const item, const x, const y, const z);

/*!
\author Xanathar
\fn itm_pileItem(const container, const item)
\brief
*/
native itm_pileItem(const container, const item);

/*!
\author Xanathar
\fn itm_reduceAmount(const item, const amount)
\brief
*/
native itm_reduceAmount(const item, const amount);

/*!
\author Xanathar
\fn itm_setContSerial(const item, const serial)
\brief
*/
native itm_setContSerial(const item, const serial);

/*!
\author Xanathar
\fn itm_setContSerOnly(const item, const serial)
\brief
*/
native itm_setContSerOnly(const item, const serial);

/*!
\author Xanathar
\fn itm_setMultiSerial(const item, const serial)
\brief
*/
native itm_setMultiSerial(const item, const serial);

/*!
\author Xanathar
\fn itm_setOwnSerial(const item, const serial)
\brief
*/
native itm_setOwnSerial(const item, const serial);

/*!
\author Xanathar
\fn itm_setOwnSerOnly(const item, const serial)
\brief
*/
native itm_setOwnSerOnly(const item, const serial);

/*!
\author Xanathar
\fn itm_setSerial(const item, const serial)
\brief
*/
native itm_setSerial(const item, const serial);

/*!
\author Xanathar
\fn itm_create(const itemtype, const container = -1, const amount = -1)
\brief Create a new item
\param itemtype the scriptid
\param container the container to put into
\param amount the amount ( if INVALID use default xss amount )
*/
native itm_create(const itemtype, const container = -1, const amount = -1);

/*!
\author Luxor
\fn itm_createByDef(const def[], const container = -1, const amount = -1);
\brief Create a new item
\param def the define
\param container the container to put into
\param amount the amount ( if INVALID use default xss amount )
*/
native itm_createByDef(const def[], const container = -1, const amount = -1);

/*!
\author Endymion
\fn itm_createInBp(const itemtype, const chr, const amount = -1)
\brief Create a new item into backpack
\param itemtype the scriptid
\param chr the character
\param amount the amount ( if INVALID use default xss amount )
*/
native itm_createInBp(const itemtype, const chr, const amount = -1);

/*!
\author Endymion
\fn itm_createInBpDef(const def[], const chr, const amount = -1)
\brief Create a new item into backpack
\param def the define
\param chr the character
\param amount the amount ( if INVALID use default xss amount )
*/
native itm_createInBpDef(const def[], const chr, const amount = -1);

/*!
\author Endymion
\fn itm_createInBank(const itemtype, const chr, const amount = -1)
\brief Create a new item into bank
\param itemtype the scriptid
\param chr the character
\param amount the amount ( if INVALID use default xss amount )
*/
native itm_createInBank(const itemtype, const chr, const amount = -1);

/*!
\author Endymion
\fn itm_createInBankDef(const def[], const chr, const amount = -1)
\brief Create a new item into bank
\param def the define
\param chr the character
\param amount the amount ( if INVALID use default xss amount )
*/
native itm_createInBankDef(const def[], const chr, const amount = -1);

/*!
\author Xanathar
\fn itm_checkDecay(const item)
\brief
*/
native itm_checkDecay(const itm);

/*!
\author Xanathar
\fn itm_remove(const item)
\brief
*/
native itm_remove(const itm);

/*!
\author Sparhawk
\fn itm_getEventHandler(const chr, const event, handler[])
\param itm:	item serial
\param event:	item event identifier (EVENT_ITM_ON*)
\brief Returns name of small function bound to the specified event into handler
*/
native itm_getEventHandler(const chr, const event, handler[]);

/*!
\author Xanathar
\fn itm_setEventHandler(const itm, const event, const evtype, const format[], ...)
\param itm:	item serial
\param event:	item event identifier (EVENT_ITM_ON*)
\param evtype:	sets dynamic or static event type (EVENTTYPE_STATIC or EVENTTYPE_DYNAMIC). Static events will be saved in worldfile.
\param format:	Name of small function to bind to the event
\brief Binds small function name to the specified event.
*/
native itm_setEventHandler(const itm, const event, const evtype, const format[], ...);

/*!
\author Xanathar
\fn itm_delEventHandler(const item, const event)
\param itm:	item serial
\param event:	item event identifier (EVENT_ITM_ON*)
\brief Unbinds link between small function an item event
*/
native itm_delEventHandler(const itm, const event);

/*!
\author Xanathar
\fn itm_sound(const item, const soundfx)
\brief
*/
native itm_sound(const itm, const soundfx);

/*!
\author Luxor
\fn itm_refresh(const item)
\brief
*/
native itm_refresh(const itm);

/*!
\author Anthalir
\fn itm_speech(const s, const itm, const text[])
\brief
*/
native itm_speech(const s, const itm, const text[]);

/*!
\author Anthalir
\fn itm_bounceToPack(const s, const item)
\brief
*/
native itm_BounceToPack(const s, const item);

/*!
\author Sparhawk
\fn itm_getLocalVarErr()
\brief Returns result for all operations on item variables
\brief Returned value is one of VAR_ERROR_NONE, VAR_ERROR_UNKNOWN_VAR, VAR_ERROR_DUPLICATE_VAR, VAR_ERROR_WRONG_TYPE, VAR_ERROR_ACCESS_DENIED
*/
native itm_getLocalVarErr();

/*!
\author Sparhawk
\fn itm_isaLocalVar(const item, const var, const type = 0)
\param item:	item serial
\param var:	variable identifier
\param type:	type of variable (VAR_TYPE_ANY, VAR_TYPE_INTEGER, VAR_TYPE_STRING )
\brief Returns true when variable exists for item. Can also be used to check wether variable is of a specific type
*/
native itm_isaLocalVar( const item, const var, const type = 0 );

/*!
\author Sparhawk
\fn itm_delLocalVar(const item, const var, const type = 0)
\param item:	item serial
\param var:	variable identifier
\param type:	type of variable (VAR_TYPE_ANY, VAR_TYPE_INTEGER, VAR_TYPE_STRING )
\brief Deletes item variable. When type is not VAR_TYPE_ANY variable is only deleted if of same type as specified.
*/
native itm_delLocalVar( const item, const var, const type = 0 );

/*!
\author Sparhawk
\fn itm_addLocalIntVar(const item, const var, const value = 0)
\param item:	item serial
\param var:	variable identifier
\param value:	initial value
\brief Adds a new integer variable to the item
*/
native itm_addLocalIntVar( const item, const var, const value = 0 );

/*!
\author Sparhawk
\fn itm_getLocalIntVar(const item, const var)
\param item:	item serial
\param var:	variable identifier
\brief Get value of specified integer variable from item.
*/
native itm_getLocalIntVar( const itm, const var );

/*!
\author Sparhawk
\fn itm_setLocalIntVar(const item, const var, const value = 0)
\param item:	item serial
\param var:	variable identifier
\param value:	new value
\brief Set the value of specified integer variable for the item
*/
native itm_setLocalIntVar( const itm, const var, const value = 0 );

/*!
\author Sparhawk
\fn itm_addLocalStrVar(const item, const var, const value[] = "")
\param item:	item serial
\param var:	variable identifier
\param value:	initial value
\brief Adds a new string variable to the item
*/
native itm_addLocalStrVar( const item, const var, const value[] = "" );

/*!
\author Sparhawk
\fn itm_getLocalStrVar(const item, const var, value[])
\param item:	item serial
\param var:	variable identifier
\brief Get value of specified string variable from item into value.
*/
native itm_getLocalStrVar( const item, const var, value[] );

/*!
\author Sparhawk
\fn itm_setLocalStrVar(const item, const var, const value[] = "")
\param item:	item serial
\param var:	variable identifier
\param value:	new value
\brief Set the value of specified string variable for the item
*/
native itm_setLocalStrVar( const item, const var, const value[] = "" );

/*!
\author Sparhawk
\fn itm_countLocalVar(const item)
\param item:	item serial
\return number of variables defined
\brief Count the number of local variables defined for specified item
*/
native itm_countLocalVar( const item );

/*!
\author Sparhawk
\fn itm_firstLocalVar(const item)
\param item:	item serial
\return first defined local variable or INVALID
\brief get id of first defined local variable
*/
native itm_firstLocalVar( const item );

/*!
\author Sparhawk
\fn itm_nextLocalVar(const item, const previous)
\param item:	item serial
\param previous: variable id of previous variable
\return next defined local variable or INVALID
\brief get id of next defined local variable
*/
native itm_nextLocalVar( const item, const previous );

/*!
\author Luxor
\fn itm_getCombatSkill(const itm)
\brief
*/
native itm_getCombatSkill(const itm);


/*!
\author ???
\fn itm_getAmxFlags(const itm, const idx)
\brief
*/
stock itm_getAmxFlags(const itm, const idx)
{
	return itm_getProperty(itm, IP_AMXFLAGS, idx);
}

/*!
\author ???
\fn itm_setAmxFlags(const itm, const idx, const value)
\brief
*/
stock itm_setAmxFlags(const itm, const idx, const value)
{
	itm_setProperty(itm, IP_AMXFLAGS, idx, value);
}

/*!
\author Rage
\fn itm_setMultiByteProperty(const itm, const property, const value)
\brief
*/
stock itm_setMultiByteProperty(const itm, const property, const value)
{
	itm_setProperty(itm, property, 1, value>>24);
	itm_setProperty(itm, property, 2, (value>>16)&0xFF);
	itm_setProperty(itm, property, 3, (value>>8)&0xFF);
	itm_setProperty(itm, property, 4, value&0xFF);
}

/*!
\author Rage
\fn itm_getMultiByteProperty(const itm, const property)
\brief
*/
stock itm_getMultiByteProperty(const itm, const property)
{
	return (itm_getProperty(itm, property, 1) << 24) + (itm_getProperty(itm, property, 2) << 16) + (itm_getProperty(itm, property, 3) << 8) + (itm_getProperty(itm, property, 4));
}
