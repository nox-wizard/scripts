// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// || NoX-Wizard	: Embedded Small Scripts			||
// || Maintained by	: Luxor, Sparhawk				||
// || Last Update	: 06-apr-2003					||
// || Designed for NXW 	: 0.82						||
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

#if defined _nxw_character_api_
  #endinput
#endif
#define _nxw_character_api_

#include "small-scripts/include/nxw_lib"

/*!
\brief Check if a serial is a char serial
\author Endymion
\fn isChar( const serial )
\param serial the serial
\return true if is a char serial, false else
\note INVALID return false
*/
public isChar( const serial ) {
	return ( ( serial>=FIRST_CHAR_SERIAL ) && ( serial<FIRST_ITEM_SERIAL ) ); 
}

/*!
\author Xanathar
\fn getCharFromSerial(const serial)
\param serial the serial
\brief Gets the char of the given serial
*/
native getCharFromSerial(const serial);

/*!
\author Xanathar
\fn getCharTarget()
\brief Gets the targetted char
*/
native getCharTarget();

/*!
\author Xanathar
\fn chr_getProperty(const chr, const property, const subprop=0, ...)
\brief
*/
native chr_getProperty(const chr, const property, const subprop=0, ...);

/*!
\author Xanathar
\fn chr_setProperty(const chr, const property, const subprop=0, ...)
\brief
*/
native chr_setProperty(const chr, const property, const subprop=0, ...);

/*!
\author Xanathar
\fn chr_canBroadcast(const chr)
\brief
*/
native chr_canBroadcast(const chr);

/*!
\author Xanathar
\fn chr_canSeeSerials(const chr)
\brief
*/
native chr_canSeeSerials(const chr);

/*!
\author Xanathar
\fn chr_canSnoop(const chr)
\brief
*/
native chr_canSnoop(const chr);

/*!
\brief Jail the given player
\author Endymion
\param jailer the jailer
\param player the player to jail
\param seconds the jail time
\note if seconds is 0 and player is jailed, player is released
*/
native chr_jail( const jailer, const player, const seconds );

/*!
\brief Release the given player from jail
\author Endymion
\param releaser the releaser
\param player the player to release
*/
public chr_unjail( const releaser, const player ) {
	chr_jail( releaser, player, 0 );
}


/*!
\author Xanathar
\fn chr_countBankGold(const chr)
\brief
*/
native chr_countBankGold(const chr);

/*!
\author Xanathar
\fn chr_countGold(const chr)
\brief
*/
native chr_countGold(const chr);

/*!
\author Xanathar
\fn chr_countItems(const chr, const itemtype, const color = -1)
\brief
*/
native chr_countItems(const chr, const itemtype, const color = -1);

/*!
\author Xanathar
\fn chr_disturbMed(const chr)
\brief
*/
native chr_disturbMed(const chr);

/*!
\author Xanathar
\fn chr_getBankBox(const chr, const bankboxtype)
\brief
*/
native chr_getBankBox(const chr, const bankboxtype);

/*!
\author Xanathar
\fn chr_getItemOnLayer(const chr, const layer)
\brief
*/
native chr_getItemOnLayer(const chr, const layer);

/*!
\author Xanathar
\fn chr_getPriv(const chr)
\brief
*/
native chr_getPriv(const chr);

/*!
\author Xanathar
\fn chr_getShield(const chr)
\brief
*/
native chr_getShield(const chr);

/*!
\author Xanathar
\fn chr_getWeapon(const chr)
\brief
*/
native chr_getWeapon(const chr);

/*!
\author Xanathar
\fn chr_isCounselor(const chr)
\brief
*/
native chr_isCounselor(const chr);

/*!
\author Xanathar
\fn chr_isCriminal(const chr)
\brief
*/
native chr_isCriminal(const chr);

/*!
\author Xanathar
\fn chr_isGM(const chr)
\brief
*/
native chr_isGM(const chr);

/*!
\author Xanathar
\fn chr_isGMorCns(const chr)
\brief
*/
native chr_isGMorCns(const chr);

/*!
\author Xanathar
\fn chr_isGrey(const chr)
\brief
*/
native chr_isGrey(const chr);

/*!
\author Xanathar
\fn chr_isHuman(const chr)
\brief
*/
native chr_isHuman(const chr);

/*!
\author Xanathar
\fn chr_isInnocent(const chr)
\brief
*/
native chr_isInnocent(const chr);

/*!
\author Xanathar
\fn chr_isInvul(const chr)
\brief
*/
native chr_isInvul(const chr);

/*!
\author Xanathar
\fn chr_isMurderer(const chr)
\brief
*/
native chr_isMurderer(const chr);

/*!
\author Xanathar
\fn chr_isTrueGM(const chr)
\brief
*/
native chr_isTrueGM(const chr);

/*!
\author Xanathar
\fn chr_makeInvul(const chr)
\brief
*/
native chr_makeInvul(const chr);

/*!
\author Xanathar
\fn chr_makeVulnerable(const chr)
\brief
*/
native chr_makeVulnerable(const chr);

/*!
\author Xanathar
\fn chr_moveTo(const chr, const x, const y, const z)
\brief
*/
native chr_moveTo(const chr, const x, const y, const z);

/*!
\author Xanathar
\fn chr_setCriminal(const chr)
\brief
*/
native chr_setCriminal(const chr);

/*!
\author Xanathar
\fn chr_setGrey(const chr)
\brief
*/
native chr_setGrey(const chr);

/*!
\author Xanathar
\fn chr_setPermaGrey(const chr)
\brief
*/
native chr_setPermaGrey(const chr);

/*!
\author Xanathar
\fn chr_setInnocent(const chr)
\brief
*/
native chr_setInnocent(const chr);

/*!
\author Xanathar
\fn chr_setMurderer(const chr)
\brief
*/
native chr_setMurderer(const chr);

/*!
\author Xanathar
\fn chr_setPriv(const chr, const priv)
\brief
*/
native chr_setPriv(const chr, const priv);

/*!
\author Xanathar
\fn chr_unhide(const chr)
\brief
*/
native chr_unhide(const chr);

/*!
\author Xanathar
\fn chr_setMultiSerial(const chr, const serial)
\brief
*/
native chr_setMultiSerial(const chr, const serial);

/*!
\author Xanathar
\fn chr_setOwnSerial(const chr, const serial)
\brief
*/
native chr_setOwnSerial(const chr, const serial);

/*!
\author Xanathar
\fn chr_setOwnSerOnly(const chr, const serial)
\brief
*/
native chr_setOwnSerOnly(const chr, const serial);

/*!
\author Xanathar
\fn chr_checkEquipment(const chr)
\brief
*/
native chr_checkEquipment(const chr);

/*!
\author Xanathar
\fn chr_addNPC(const npcnum, const x, const y, const z)
\brief
*/
native chr_addNPC(const npcnum, const x, const y, const z);

/*!
\author Xanathar
\fn chr_remove(const chr)
\brief
*/
native chr_remove(const chr);

/*!
\author Xanathar
\fn chr_calcAtt(const chr)
\brief
*/
native chr_calcAtt (const chr);

/*!
\author Xanathar
\fn chr_calcDef(const chr)
\brief
*/
native chr_calcDef (const chr);

/*!
\author Xanathar
\fn chr_fish(const chr)
\brief
*/
native chr_fish (const chr);

/*!
\author Sparhawk
\since 0.82.rc3
\fn chr_getGuild( const chr )
\brief Get guild serial for new guild system
*/
native chr_getGuild( const chr );


/*!
\author Xanathar
\fn chr_guildCompare(const chr1, const chr2)
\brief
*/
native chr_guildCompare (const chr1, const chr2);

/*!
\author Xanathar
\fn chr_attackStuff(const chr_defender, const socket_attacker)
\brief
*/
native chr_attackStuff (const chr_defender, const socket_attacker);

/*!
\author Xanathar
\fn chr_helpStuff(const chr_target, const socket_helper)
\brief
*/
native chr_helpStuff (const chr_target, const socket_helper);

/*!
\author Xanathar
\fn chr_action(const chr, const action)
\brief
*/
native chr_action (const chr, const action);

/*!
\author Xanathar
\fn chr_checkSkill(const chr, const skill, const min=0, const max=1000, const raise=1)
\brief
*/
native chr_checkSkill(const chr, const skill, const min=0, const max=1000, const raise=1);

/*!
\author Xanathar
\fn chr_unmountHorse(const chr)
\brief
*/
native chr_unmountHorse(const chr);

/*!
\author Xanathar
\fn chr_mountHorse(const chr, const horse_chr)
\brief
*/
native chr_mountHorse(const chr, const horse_chr);

/*!
\brief Equip given item
\author Endymion
\fn chr_equip(const chr, const item)
*/
native chr_equip(const chr, const item);

/*!
\author Xanathar
\fn chr_resurrect(const chr)
\brief
*/
native chr_resurrect(const chr);

/*!
\author Sparhawk
\fn chr_getEventHandler(const chr, const event, handler[])
\param chr:	character serial
\param event:	character event identifier (EVENT_CHR_ON*)
\brief Returns name of small function bound to the specified event into handler
*/
native chr_getEventHandler(const chr, const event, handler[]);

/*!
\author Xanathar
\fn chr_setEventHandler(const chr, const event, const evtype, const format[], ...)
\param chr:	character serial
\param event:	character event identifier (EVENT_CHR_ON*)
\param evtype:	sets dynamic or static event type (EVENTTYPE_STATIC or EVENTTYPE_DYNAMIC). Static events will be saved in worldfile.
\param format:	Name of small function to bind to the event
\brief Binds a small function to a character event
*/
native chr_setEventHandler(const chr, const event, const evtype, const format[], ...);

/*!
\author Xanathar
\fn chr_delEventHandler(const chr, const event)
\param chr:	character serial
\param event:	character event identifier (EVENT_CHR_ON*)
\brief Unbinds link between a character event and a small function
*/
native chr_delEventHandler(const chr, const event);

/*!
\author Xanathar
\fn chr_sound(const chr, const soundfx)
\brief
*/
native chr_sound(const chr, const soundfx);

/*!
\author Xanathar
\fn chr_distance(const chr1, const chr2)
\brief
*/
native chr_distance(const chr1, const chr2);

/*!
\author Luxor
\fn chr_npcAttack(const attacker, const target)
\brief
*/
native chr_npcAttack(const attacker, const target);

/*!
\author Luxor
\fn chr_update(const chr)
\brief
*/
native chr_update(const chr);

/*!
\author Luxor
\fn chr_npcRelease(const chr)
\brief
*/
native chr_npcRelease(const chr);

/*!
\author Luxor
\fn chr_owns(const chr1, const chr2)
\brief
*/
native chr_owns(const chr1, const chr2);

/*!
\author Sparhawk
\fn chr_speech(const function, const chr = -1, const npc, const text[], const antispam = 1)
\brief
*/
native chr_speech(const function, const chr = -1, const npc, const text[], const antispam = 1);

/*!
\author Luxor
\fn chr_teleport(const chr)
\brief
*/
native chr_teleport(const chr);

/*!
\author Luxor
\fn chr_lineOfSight(const s, const x1, const y1, const z1, const x2, const y2, const z2, const checkfor)
\brief
*/
native chr_lineOfSight(const s, const x1, const y1, const z1, const x2, const y2, const z2, const checkfor);

/*!
\author Luxor
\fn chr_poison(const chr, const poisontype, const secs = -1)
\brief
*/
native chr_poison(const chr, const poisontype, const secs = -1);

/*!
\author Luxor
\fn chr_hide(const chr, const hidden)
\brief
*/
native chr_hide(const chr, const hidden);

/*!
\author Luxor
\fn chr_applyDamage(const chr, const damage, const damagetype, const stattobedamaged)
\brief
*/
native chr_applyDamage(const chr, const damage, const damagetype, const stattobedamaged);

/*!
\author Luxor
\fn chr_setRandomName(const chr, const namelist[])
\brief
*/
native chr_setRandomName(const chr, const namelist[]);

/*!
\author Sparhawk
\fn (const showToWhom, const showWhom, const msg[], const color = 0x0481)
\brief
*/
native chr_showMessage(const showToWhom, const showWhom, const msg[], const color = 0x0481);

/*!
\author Sparhawk
\fn chr_getGuildType(const chr)
\brief
*/
native chr_getGuildType( const chr );

/*!
\author Sparhawk
\fn chr_setGuildType(const chr, const type)
\brief
*/
native chr_setGuildType( const chr, const type );

/*!
\author Sparhawk
\fn chr_isGuildTraitor(const chr)
\brief
*/
native chr_isGuildTraitor( const chr );

/*!
\author Sparhawk
\fn chr_setGuildTraitor(const chr, const traitor = 1)
\brief
*/
native chr_setGuildTraitor( const chr, const traitor = 1 );

/*!
\author Sparhawk
\fn chr_hasGuildToggle(const chr)
\brief
*/
native chr_hasGuildToggle( const chr );

/*!
\author Sparhawk
\fn chr_setGuildToggle(const chr, const toggle = 1)
\brief
*/
native chr_setGuildToggle( const chr, const toggle = 1 );

/*!
\author Sparhawk
\fn chr_getGuildFealty(const chr)
\brief
*/
native chr_getGuildFealty( const chr );

/*!
\author Sparhawk
\fn chr_setGuildFealty(const chr, const fealty)
\brief
*/
native chr_setGuildFealty( const chr, const fealty );

/*!
\author Sparhawk
\fn chr_getGuildNumber(const chr)
\brief
*/
native chr_getGuildNumber( const chr );

/*!
\author Sparhawk
\fn chr_setGuildNumber(const chr)
\brief
*/
native chr_setGuildNumber( const chr, const number );

/*!
\author Sparhawk
\fn chr_getGuildTitle(const chr, title[])
\brief
*/
native chr_getGuildTitle( const chr, title[] );

/*!
\author Sparhawk
\fn chr_setGuildTitle(const chr, const title[])
\brief
*/
native chr_setGuildTitle( const chr, const title[] );

/*!
\author Sparhawk
\fn chr_getCreationDay(const chr)
\brief
*/
native chr_getCreationDay( const chr );

/*!
\author Sparhawk
\fn chr_setCreationDay(const chr, const day)
\brief
*/
native chr_setCreationDay( const chr, const day );

/*!
\author Luxor
\fn chr_morph(const chr, const bodyid, const skincolor, const hairstyle, const haircolor, const beardstyle, const beardcolor, const backup, const format[], ...)
\brief
*/
native chr_morph( const chr, const bodyid, const skincolor, const hairstyle, const haircolor, const beardstyle, const beardcolor, const backup, const format[], ... );

/*!
\author Luxor
\fn chr_unmorph(const chr)
\brief
*/
native chr_unmorph( const chr );

/*!
\brief Get character backpack
\author Endymion
\fn chr_getBackpack(const chr)
\param chr the character
\param createIfNotExist if true backpack is created if not exist
*/
native chr_getBackpack( const chr, const createIfNotExist = true );

/*!
\author Keldan
\fn chr_possess(const possessor, const possessed)
\brief made "possessor" character possess "possessed" character. Possessor can't be NPC.
*/
native chr_possess(const possessor, const possessed);

/*!
\author Sparhawk
\fn chr_getLocalVarErr()
\brief Returns result for all operations on character variables
\brief Returned value is one of VAR_ERROR_NONE, VAR_ERROR_UNKNOWN_VAR, VAR_ERROR_DUPLICATE_VAR, VAR_ERROR_WRONG_TYPE, VAR_ERROR_ACCESS_DENIED
*/
native chr_getLocalVarErr();

/*!
\author Sparhawk
\fn chr_isaLocalVar(const chr, const var, const type = 0)
\param chr:	character serial
\param var:	variable identifier
\param type:	type of variable (VAR_TYPE_ANY, VAR_TYPE_INTEGER, VAR_TYPE_STRING )
\brief Returns true when variable exists for character. Can also be used to check wether variable is of a specific type
*/
native chr_isaLocalVar( const chr, const var, const type = 0 );

/*!
\author Sparhawk
\fn chr_sizeofLocalVar( const serial, const var, const index = -1 )
\brief Returns length of a local variable, number of elements in a vector, or length of variable in a vector
*/
native chr_sizeofLocalVar( const serial, const var, const index = -1 );

/*!
\author Sparhawk
\fn chr_delLocalVar(const chr, const var, const type = 0)
\param chr:	character serial
\param var:	variable identifier
\param type:	type of variable (VAR_TYPE_ANY, VAR_TYPE_INTEGER, VAR_TYPE_STRING )
\brief Deletes character variable. When type is not VAR_TYPE_ANY variable is only deleted if of same type as specified.
*/
native chr_delLocalVar( const chr, const var, const type = 0 );

/*!
\author Sparhawk
\fn chr_addLocalIntVar(const chr, const var, const value = 0)
\param chr:	character serial
\param var:	variable identifier
\param value:	initial value
\brief Adds a new integer variable to the character
*/
native chr_addLocalIntVar( const chr, const var, const value = 0 );

/*!
\author Sparhawk
\fn chr_getLocalIntVar(const chr, const var)
\param chr:	character serial
\param var:	variable identifier
\brief Get value of specified integer variable from character
*/
native chr_getLocalIntVar( const chr, const var );

/*!
\author Sparhawk
\fn chr_setLocalIntVar(const chr, const var, const value = 0)
\param chr:	character serial
\param var:	variable identifier
\param value:	new value
\brief Set the value of specified integer variable for the character
*/
native chr_setLocalIntVar( const chr, const var, const value = 0 );

/*!
\author Sparhawk
\fn chr_addLocalIntVec(const chr, const var, const size = 1, const value = 0)
\param chr:	character serial
\param var:	variable identifier
\param size	number of array elements
\param value:	initial value
\brief Adds a new integer variable array to the character
*/
native chr_addLocalIntVec( const chr, const var, const size = 1, const value = 0 );

/*!
\author Sparhawk
\fn chr_getLocalIntVec(const chr, const var, const index = 0)
\param chr:	character serial
\param var:	variable identifier
\param index:	0 based index into array
\brief Get value of specified integer variable from character
*/
native chr_getLocalIntVec( const chr, const var, const index = 0);

/*!
\author Sparhawk
\fn chr_setLocalIntVec(const chr, const var, const index = 0, const value = 0)
\param chr:	character serial
\param var:	variable identifier
\param index:	0 based index into array
\param value:	new value
\brief Set the value of specified integer variable for the character
*/
native chr_setLocalIntVec( const chr, const var, const index = 0, const value = 0 );

/*!
\author Sparhawk
\fn chr_addLocalStrVar(const chr, const var, const value[] = "")
\param chr:	character serial
\param var:	variable identifier
\param value:	initial value
\brief Adds a new string variable to the character
*/
native chr_addLocalStrVar( const chr, const var, const value[] = "" );

/*!
\author Sparhawk
\fn chr_getLocalStrVar(const chr, const var, value[])
\param chr:	character serial
\param var:	variable identifier
\brief Get value of specified string variable from character into value.
*/
native chr_getLocalStrVar( const chr, const var, value[] );

/*!
\author Sparhawk
\fn chr_setLocalStrVar(const chr, const var, const value[] = "")
\param chr:	character serial
\param var:	variable identifier
\param value:	new value
\brief Set the value of specified string variable for the character
*/
native chr_setLocalStrVar( const chr, const var, const value[] = "" );

/*!
\author Sparhawk
\fn chr_countLocalVar(const chr)
\param chr:	character serial
\return number of variables defined
\brief Count the number of local variables defined for specified character
*/
native chr_countLocalVar( const chr );

/*!
\author Sparhawk
\fn chr_firstLocalVar(const chr)
\param chr:	character serial
\return first defined local variable or INVALID
\brief get id of first defined local variable
*/
native chr_firstLocalVar( const chr );

/*!
\author Sparhawk
\fn chr_nextLocalVar(const chr, const previous)
\param chr:	character serial
\param previous: variable id of previous variable
\return next defined local variable or INVALID
\brief get id of next defined local variable
*/
native chr_nextLocalVar( const chr, const previous );

/*!
\author Luxor
\fn chr_skillMakeMenu(const chr, const makeMenu, const skill)
\brief
*/
native chr_skillMakeMenu(const chr, const makeMenu, const skill);


/*!
\author Luxor
\fn chr_isOnline(const chr)
\brief
*/
native chr_isOnline(const chr);


/*!
\brief Check if character is frozen
\author Endymion
\fn chr_isFrozen(const chr)
*/
public chr_isFrozen(const chr) {
	return chr_getProperty( chr, CP_FROZEN );
}


/*!
\author Luxor
\fn chr_doCombatAction(const chr)
\brief
*/
native chr_doCombatAction(const chr);

/*!
\brief Stable an npc
\author Endymion
\fn chr_stable(const chr, const stablemaster)
\param chr the npc to stable
\param stablemaster the stablemaster
*/
native chr_stable(const chr, const stablemaster);

/*!
\brief Unstable an npc
\author Endymion
\fn chr_unStable(const chr)
\param chr the npc
*/
native chr_unStable(const chr);


/*!
\author ???
\fn chr_getInt(const chr)
\brief
*/
stock chr_getInt(const chr)
{
	return chr_getProperty(chr, CP_INTELLIGENCE, CP2_EFF);
}

/*!
\author ???
\fn chr_getRealInt(const chr)
\brief
*/
stock chr_getRealInt(const chr)
{
	return chr_getProperty(chr, CP_INTELLIGENCE, CP2_REAL);
}

/*!
\author ???
\fn chr_getMana(const chr)
\brief
*/
stock chr_getMana(const chr)
{
	return chr_getProperty(chr, CP_INTELLIGENCE, CP2_ACT);
}

/*!
\author ???
\fn chr_getDex(const chr)
\brief
*/
stock chr_getDex(const chr)
{
	return chr_getProperty(chr, CP_DEXTERITY, CP2_EFF);
}

/*!
\author ???
\fn chr_getRealDex(const chr)
\brief
*/
stock chr_getRealDex(const chr)
{
	return chr_getProperty(chr, CP_DEXTERITY, CP2_REAL);
}

/*!
\author ???
\fn chr_getStamina(const chr)
\brief
*/
stock chr_getStamina(const chr)
{
	return chr_getProperty(chr, CP_DEXTERITY, CP2_ACT);
}

/*!
\author ???
\fn chr_getStr(const chr)
\brief
*/
stock chr_getStr(const chr)
{
	return chr_getProperty(chr, CP_STRENGHT, CP2_EFF);
}

/*!
\author ???
\fn chr_getRealStr(const chr)
\brief
*/
stock chr_getRealStr(const chr)
{
	return chr_getProperty(chr, CP_STRENGHT, CP2_REAL);
}

/*!
\author ???
\fn chr_getHitPoints(const chr)
\brief
*/
stock chr_getHitPoints(const chr)
{
	return chr_getProperty(chr, CP_STRENGHT, CP2_ACT);
}

/*!
\author ???
\fn chr_setHitPoints(const chr, const value)
\brief
*/
stock chr_setHitPoints(const chr, const value)
{
	chr_setProperty(chr, CP_STRENGHT, CP2_ACT, value);
}

/*!
\author ???
\fn chr_setStamina(const chr, const value)
\brief
*/
stock chr_setStamina(const chr, const value)
{
	chr_setProperty(chr, CP_DEXTERITY, CP2_ACT, value);
}

/*!
\author ???
\fn chr_setMana(const chr, const value)
\brief
*/
stock chr_setMana(const chr, const value)
{
	chr_setProperty(chr, CP_INTELLIGENCE, CP2_ACT, value);
}

/*!
\author ???
\fn chr_getAmxFlags(const chr, const idx)
\brief
*/
stock chr_getAmxFlags(const chr, const idx)
{
	return chr_getProperty(chr, CP_AMXFLAGS, idx);
}

/*!
\author ???
\fn chr_setAmxFlags(const chr, const idx, const value)
\brief
*/
stock chr_setAmxFlags(const chr, const idx, const value)
{
	chr_setProperty(chr, CP_AMXFLAGS, idx, value);
}

/*!
\author ???
\fn chr_getSkill(const chr, const skill)
\brief
*/
stock chr_getSkill(const chr, const skill)
{
	return chr_getProperty(chr, CP_SKILL, skill);
}

/*!
\author ???
\fn chr_getBaseSkill(const chr, const skill)
\brief
*/
stock chr_getBaseSkill(const chr, const skill)
{
	return chr_getProperty(chr, CP_BASESKILL, skill);
}

/*!
\author ???
\fn chr_setBaseSkill(const chr, const skill, const value)
\brief
*/
stock chr_setBaseSkill(const chr, const skill, const value)
{
	chr_setProperty(chr, CP_BASESKILL, skill, value);
}

/*!
\author ???
\fn chr_damage(const chr, const basedamage, const attacker = -1, const magiclike = 0, const damagetype = DAMAGE_PURE, const stattobedamaged = 0)
\brief
*/
stock chr_damage(const chr, const basedamage, const attacker = -1, const magiclike = 0, const damagetype = DAMAGE_PURE, const stattobedamaged = 0)
{
	new ai = chr_getProperty(chr, CP_NPCAI);
	new damage = basedamage;

	if (chr_isInvul(chr)) return 0;
	if (ai==17) return 0; //player vendors

	if (magiclike!=0) {
		if (0!=chr_getProperty(chr, CP_NPC)) damage *= 2;
	}

	chr_applyDamage(chr, damage, damagetype, stattobedamaged);

	if (attacker>=0) chr_attackStuff(chr, attacker);
	return damage;
}

/*!
\author ???
\fn chr_talk(const chr, const npc, const text[], const antispam = 1)
\brief
*/
stock chr_talk(const chr, const npc, const text[], const antispam = 1)
{ 
	chr_speech(NPC_TALK, chr, npc, text, antispam);
} 

/*!
\author ???
\fn chr_talkall(const npc, const text[], const antispam = 1)
\brief
*/
stock chr_talkall(const npc, const text[], const antispam = 1)
{ 
	chr_speech(NPC_TALK_ALL, _, npc, text, antispam);
}

/*!
\author ???
\fn chr_talkRunic(const chr, const npc, const text[], const antispam = 1)
\brief
*/
stock chr_talkRunic(const chr, const npc, const text[], const antispam = 1)
{ 
	chr_speech(NPC_TALK_RUNIC, chr, npc, text, antispam);
} 

/*!
\author ???
\fn chr_talkallRunic(const npc, const text[], const antispam = 1)
\brief
*/
stock chr_talkallRunic(const npc, const text[], const antispam = 1)
{ 
	chr_speech(NPC_TALK_ALL_RUNIC, _, npc, text, antispam);
} 

/*!
\author ???
\fn chr_emote(const chr, const npc, const text[], const antispam = 1)
\brief
*/
stock chr_emote(const chr, const npc, const text[], const antispam = 1)
{ 
	chr_speech(NPC_EMOTE, chr, npc, text, antispam);
} 

/*!
\author ???
\fn chr_emoteall(const npc, const text[], const antispam = 1)
\brief
*/
stock chr_emoteall(const npc, const text[], const antispam = 1)
{
	chr_speech(NPC_EMOTE_ALL, _, npc, text, antispam);
}

/*!
\author Luxor
\fn chr_isNpc(const chr)
\brief
*/
public chr_isNpc (const chr)
{
	new npc = chr_getProperty(chr, CP_NPC);
	//new acc = chr_getProperty(chr, CP_ACCOUNT);

	//if (acc!=-1) return 0;
	return npc;
}

/*!
\author ???
\fn chr_isUndead(const chr)
\brief
*/
public chr_isUndead (const chr)
{
	return ( chr_getProperty(chr, CP_NPCRACE) == 1 );
}

/*!
\author Luxor
\fn chr_setTamed(const chr, const npc)
\brief
*/
public chr_setTamed (const chr, const npc)
{
	new ownser = chr_getProperty(chr, CP_SERIAL);
	chr_setOwnSerial(npc, ownser);

	chr_setProperty(npc, CP_TAMED, _, 1);
	chr_setProperty(npc, CP_NPCWANDER, _, 0);
	chr_setProperty(npc, CP_NPCAI, _, 10);
}


/*!
\brief Flee the npc
\author Endymion
\param npc
\param from
\param seconds
*/
native chr_flee( const npc, const from, const seconds );

/*!
\brief Get the direction for see location
\author Endymion
\param chr
\param x the x location
\param y the y location
\return the direction
*/
public chr_getDirForSee( const chr, const x, const y )
{
	new chr_x = chr_getProperty( chr, CP_POSITION, CP2_X );
	new chr_y = chr_getProperty( chr, CP_POSITION, CP2_Y );
	
	if ((chr_x == x) && (chr_y == y))
		return chr_getProperty( chr, CP_DIR );

	if (chr_x == x) {
		if (chr_y > y)
			return NORTH; // north
		else
			return SOUTH; // south
	}
	else
	{
		/*new coef;
		float(coef)
		coef =(y - chr_y) / (x - chr_x);
		if (chr_x < x) // facing east
			if (coef > 2)
				return SOUTH;
			else if (coef > 0.5)
				return SOUTHEAST;
			else if (coef > -0.5)
				return EAST;
			else if (coef > -2)
				return NORTHEAST;
			else return NORTH;
		else // facing west
			if (coef > 2)
				return NORTH;
			else if (coef > 0.5)
				return NORTHWEST; // south-west
			else if (coef > -0.5)
				return WEST; // west
			else if (coef > -2)
				return SOUTHWEST; // north-west
			else return SOUTH;
		*/
	}
	return SOUTH;
}
